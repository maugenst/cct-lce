
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for cct-lce/dist.browser/bundle.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">cct-lce/dist.browser</a> bundle.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/1914</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1859</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/627</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var e=<span class="cstat-no" title="statement not covered" >{8599:<span class="fstat-no" title="function not covered" >e=</span>&gt;{"use strict";const{AbortController:t,AbortSignal:n}=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0;<span class="cstat-no" title="statement not covered" ></span>e.exports=t,e.exports.AbortSignal=n,e.exports.default=t}</span>,1227:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{<span class="cstat-no" title="statement not covered" >t.formatArgs=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >"color: "+this.color;<span class="cstat-no" title="statement not covered" ></span>t.splice(1,0,n,"color: inherit");l</span>et r=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t[0].replace(/%[a-zA-Z%]/g,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >"%%"!==e&amp;&amp;(r++,"%c"===e&amp;&amp;(s=r))}</span>)),t.splice(s,0,n)}</span>,t.save=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}</span>catch(e){}}</span>,t.load=<span class="fstat-no" title="function not covered" >fu</span>nction(){let e;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e=t.storage.getItem("debug")}</span>catch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn!e&amp;&amp;"undefined"!=typeof process&amp;&amp;"env"in process&amp;&amp;(e=process.env.DEBUG),e}</span>,t.useColors=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&amp;&amp;!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&amp;&amp;("undefined"!=typeof document&amp;&amp;document.documentElement&amp;&amp;document.documentElement.style&amp;&amp;document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&amp;&amp;window.console&amp;&amp;(window.console.firebug||window.console.exception&amp;&amp;window.console.table)||"undefined"!=typeof navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&amp;&amp;parseInt(RegExp.$1,10)&gt;=31||"undefined"!=typeof navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}</span>,t.storage=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return localStorage}</span>catch(e){}}</span>(),t.destroy=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}</span>}</span>)(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(<span class="fstat-no" title="function not covered" >()</span>=&gt;{}),e.exports=n(2447)(t);c</span>onst{formatters:r}=<span class="cstat-no" title="statement not covered" >e.exports;<span class="cstat-no" title="statement not covered" ></span>r.j=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.stringify(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return"[UnexpectedJSONParseError]: "+e.message}</span>}</span>}</span>,2447:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){function <span class="fstat-no" title="function not covered" >t(</span>e){let n,s,o,i=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >a(</span>...e){<span class="cstat-no" title="statement not covered" >if(!a.enabled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >a,</span>s=<span class="cstat-no" title="statement not covered" >Number(new Date),</span>o=<span class="cstat-no" title="statement not covered" >s-(n||s);<span class="cstat-no" title="statement not covered" ></span>r.diff=o,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&amp;&amp;e.unshift("%O");l</span>et i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e[0]=e[0].replace(/%([a-zA-Z%])/g,(<span class="fstat-no" title="function not covered" >(n</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if("%%"===n)<span class="cstat-no" title="statement not covered" >return"%";<span class="cstat-no" title="statement not covered" >i</span></span>++;c</span>onst o=<span class="cstat-no" title="statement not covered" >t.formatters[s];<span class="cstat-no" title="statement not covered" ></span>if("function"==typeof o){const t=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>n=o.call(r,t),e.splice(i,1),i--}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>)),t.formatArgs.call(r,e),(r.log||t.log).apply(r,e)}<span class="cstat-no" title="statement not covered" ></span>return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null!==i?i:(s!==t.namespaces&amp;&amp;(s=t.namespaces,o=t.enabled(e)),o),</span>set:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=e}</span>}),"function"==typeof t.init&amp;&amp;t.init(a),a}</span>function <span class="fstat-no" title="function not covered" >r(</span>e,n){const r=<span class="cstat-no" title="statement not covered" >t(this.namespace+(void 0===n?":":n)+e);<span class="cstat-no" title="statement not covered" ></span>return r.log=this.log,r}</span>function <span class="fstat-no" title="function not covered" >s(</span>e){<span class="cstat-no" title="statement not covered" >return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}<span class="cstat-no" title="statement not covered" ></span>return t.debug=t,t.default=t,t.coerce=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e instanceof Error?e.stack||e.message:e}</span>,t.disable=<span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >[...t.names.map(s),...t.skips.map(s).map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"-"+e)</span>)].join(",");<span class="cstat-no" title="statement not covered" ></span>return t.enable(""),e}</span>,t.enable=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let n;<span class="cstat-no" title="statement not covered" >t.save(e),t.namespaces=e,t.names=[],t.skips=[];c</span>onst r=<span class="cstat-no" title="statement not covered" >("string"==typeof e?e:"").split(/[\s,]+/),</span>s=<span class="cstat-no" title="statement not covered" >r.length;<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;s;n++)<span class="cstat-no" title="statement not covered" >r[n]&amp;&amp;("-"===(e=r[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))}</span></span>,t.enabled=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("*"===e[e.length-1])<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et n,r;<span class="cstat-no" title="statement not covered" >for(n=0,r=t.skips.length;n&lt;r;n++)<span class="cstat-no" title="statement not covered" >if(t.skips[n].test(e))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(n=0,r=t.names.length;n&lt;r;n++)<span class="cstat-no" title="statement not covered" >if(t.names[n].test(e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,t.humanize=n(7824),t.destroy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}</span>,Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >t[n]=e[n]}</span>)),t.names=[],t.skips=[],t.formatters={},t.selectColor=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t++)<span class="cstat-no" title="statement not covered" >n=(n&lt;&lt;5)-n+e.charCodeAt(t),n|=0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.colors[Math.abs(n)%t.colors.length]}</span>,t.enable(t.load()),t}</span>}</span>,7187:<span class="fstat-no" title="function not covered" >e=</span>&gt;{"use strict";var t,n=<span class="cstat-no" title="statement not covered" >"object"==typeof Reflect?Reflect:null,</span>r=<span class="cstat-no" title="statement not covered" >n&amp;&amp;"function"==typeof n.apply?n.apply:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return Function.prototype.apply.call(e,t,n)}</span>;<span class="cstat-no" title="statement not covered" ></span>t=n&amp;&amp;"function"==typeof n.ownKeys?n.ownKeys:Object.getOwnPropertySymbols?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyNames(e)}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >Number.isNaN||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!=e}</span>;</span>function <span class="fstat-no" title="function not covered" >o(</span>){<span class="cstat-no" title="statement not covered" >o.init.call(this)}<span class="cstat-no" title="statement not covered" ></span>e.exports=o,e.exports.once=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){function <span class="fstat-no" title="function not covered" >s(</span>n){<span class="cstat-no" title="statement not covered" >e.removeListener(t,o),r(n)}</span>function <span class="fstat-no" title="function not covered" >o(</span>){<span class="cstat-no" title="statement not covered" >"function"==typeof e.removeListener&amp;&amp;e.removeListener("error",s),n([].slice.call(arguments))}<span class="cstat-no" title="statement not covered" ></span>y(e,t,o,{once:!0}),"error"!==t&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >"function"==typeof e.on&amp;&amp;y(e,"error",t,{once:!0})}</span>(e,s)}</span>))}</span>,o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;v</span>ar i=<span class="cstat-no" title="statement not covered" >10;</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}</span></span>function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t,n,r){var s,o,i,u;<span class="cstat-no" title="statement not covered" >if(a(n),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&amp;&amp;(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),i=o[t]),void 0===i)<span class="cstat-no" title="statement not covered" >i=o[t]=n,++e._eventsCount;e</span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof i?i=o[t]=r?[n,i]:[i,n]:r?i.unshift(n):i.push(n),(s=c(e))&gt;0&amp;&amp;i.length&gt;s&amp;&amp;!i.warned){<span class="cstat-no" title="statement not covered" >i.warned=!0;v</span>ar l=<span class="cstat-no" title="statement not covered" >new Error("Possible EventEmitter memory leak detected. "+i.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");<span class="cstat-no" title="statement not covered" ></span>l.name="MaxListenersExceededWarning",l.emitter=e,l.type=t,l.count=i.length,u=l,console&amp;&amp;console.warn&amp;&amp;console.warn(u)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >l(</span>){<span class="cstat-no" title="statement not covered" >if(!this.fired)<span class="cstat-no" title="statement not covered" >return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}</span></span>function <span class="fstat-no" title="function not covered" >h(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >{fired:!1,wrapFn:void 0,target:e,type:t,listener:n},</span>s=<span class="cstat-no" title="statement not covered" >l.bind(r);<span class="cstat-no" title="statement not covered" ></span>return s.listener=n,r.wrapFn=s,s}</span>function <span class="fstat-no" title="function not covered" >d(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e._events;<span class="cstat-no" title="statement not covered" ></span>if(void 0===r)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar s=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>return void 0===s?[]:"function"==typeof s?n?[s.listener||s]:[s]:n?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >new Array(e.length),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >t[n]=e[n].listener||e[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>(s):p(s,s.length)}</span>function <span class="fstat-no" title="function not covered" >f(</span>e){var t=<span class="cstat-no" title="statement not covered" >this._events;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t){var n=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>if("function"==typeof n)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==n)<span class="cstat-no" title="statement not covered" >return n.length}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn 0}</span>function <span class="fstat-no" title="function not covered" >p(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new Array(t),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t;++r)<span class="cstat-no" title="statement not covered" >n[r]=e[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >y(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >if("function"==typeof e.on)<span class="cstat-no" title="statement not covered" >r.once?e.once(t,n):e.on(t,n);e</span>lse{<span class="cstat-no" title="statement not covered" >if("function"!=typeof e.addEventListener)<span class="cstat-no" title="statement not covered" >throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);<span class="cstat-no" title="statement not covered" >e</span></span>.addEventListener(t,(function <span class="fstat-no" title="function not covered" >s(</span>o){<span class="cstat-no" title="statement not covered" >r.once&amp;&amp;e.removeEventListener(t,s),n(o)}</span>))}</span>}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("number"!=typeof e||e&lt;0||s(e))<span class="cstat-no" title="statement not covered" >throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");<span class="cstat-no" title="statement not covered" >i</span></span>=e}</span>}),o.init=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >void 0!==this._events&amp;&amp;this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0}</span>,o.prototype.setMaxListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("number"!=typeof e||e&lt;0||s(e))<span class="cstat-no" title="statement not covered" >throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._maxListeners=e,this}</span>,o.prototype.getMaxListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c(this)}</span>,o.prototype.emit=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;arguments.length;n++)<span class="cstat-no" title="statement not covered" >t.push(arguments[n]);v</span></span>ar s=<span class="cstat-no" title="statement not covered" >"error"===e,</span>o=<span class="cstat-no" title="statement not covered" >this._events;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==o)<span class="cstat-no" title="statement not covered" >s=s&amp;&amp;void 0===o.error;e</span>lse <span class="cstat-no" title="statement not covered" >if(!s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(s){var i;<span class="cstat-no" title="statement not covered" >if(t.length&gt;0&amp;&amp;(i=t[0]),i instanceof Error)<span class="cstat-no" title="statement not covered" >throw i;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >new Error("Unhandled error."+(i?" ("+i.message+")":""));<span class="cstat-no" title="statement not covered" ></span>throw a.context=i,a}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >o[e];<span class="cstat-no" title="statement not covered" ></span>if(void 0===c)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f("function"==typeof c)<span class="cstat-no" title="statement not covered" >r(c,this,t);e</span>lse{var u=<span class="cstat-no" title="statement not covered" >c.length,</span>l=<span class="cstat-no" title="statement not covered" >p(c,u);<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;u;++n)<span class="cstat-no" title="statement not covered" >r(l[n],this,t)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}</span>,o.prototype.addListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return u(this,e,t,!1)}</span>,o.prototype.on=o.prototype.addListener,o.prototype.prependListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return u(this,e,t,!0)}</span>,o.prototype.once=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return a(t),this.on(e,h(this,e,t)),this}</span>,o.prototype.prependOnceListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return a(t),this.prependListener(e,h(this,e,t)),this}</span>,o.prototype.removeListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n,r,s,o,i;<span class="cstat-no" title="statement not covered" >if(a(t),void 0===(r=this._events))<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0===(n=r[e]))<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(n===t||n.listener===t)<span class="cstat-no" title="statement not covered" >0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&amp;&amp;this.emit("removeListener",e,n.listener||t));e</span>lse <span class="cstat-no" title="statement not covered" >if("function"!=typeof n){<span class="cstat-no" title="statement not covered" >for(s=-1,o=n.length-1;o&gt;=0;o--)<span class="cstat-no" title="statement not covered" >if(n[o]===t||n[o].listener===t){<span class="cstat-no" title="statement not covered" >i=n[o].listener,s=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(s&lt;0)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >0</span></span>===s?n.shift():<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(;t+1&lt;e.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=e[t+1];<span class="cstat-no" title="statement not covered" >e</span></span>.pop()}</span>(n,s),1===n.length&amp;&amp;(r[e]=n[0]),void 0!==r.removeListener&amp;&amp;this.emit("removeListener",e,i||t)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this}</span>,o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,n,r;<span class="cstat-no" title="statement not covered" >if(void 0===(n=this._events))<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0===n.removeListener)<span class="cstat-no" title="statement not covered" >return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&amp;&amp;(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===arguments.length){var s,o=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>for(r=0;r&lt;o.length;++r)<span class="cstat-no" title="statement not covered" >"removeListener"!==(s=o[r])&amp;&amp;this.removeAllListeners(s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}<span class="cstat-no" title="statement not covered" ></span>i</span>f("function"==typeof(t=n[e]))<span class="cstat-no" title="statement not covered" >this.removeListener(e,t);e</span>lse <span class="cstat-no" title="statement not covered" >if(void 0!==t)<span class="cstat-no" title="statement not covered" >for(r=t.length-1;r&gt;=0;r--)<span class="cstat-no" title="statement not covered" >this.removeListener(e,t[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn this}</span>,o.prototype.listeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return d(this,e,!0)}</span>,o.prototype.rawListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return d(this,e,!1)}</span>,o.listenerCount=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return"function"==typeof e.listenerCount?e.listenerCount(t):f.call(e,t)}</span>,o.prototype.listenerCount=f,o.prototype.eventNames=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._eventsCount&gt;0?t(this._events):[]}</span>}</span>,7824:<span class="fstat-no" title="function not covered" >e=</span>&gt;{var t=<span class="cstat-no" title="statement not covered" >1e3,</span>n=<span class="cstat-no" title="statement not covered" >60*t,</span>r=<span class="cstat-no" title="statement not covered" >60*n,</span>s=<span class="cstat-no" title="statement not covered" >24*r;</span>function <span class="fstat-no" title="function not covered" >o(</span>e,t,n,r){var s=<span class="cstat-no" title="statement not covered" >t&gt;=1.5*n;<span class="cstat-no" title="statement not covered" ></span>return Math.round(e/n)+" "+r+(s?"s":"")}<span class="cstat-no" title="statement not covered" ></span>e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >i=i||{};v</span>ar a,c,u=<span class="cstat-no" title="statement not covered" >typeof e;<span class="cstat-no" title="statement not covered" ></span>if("string"===u&amp;&amp;e.length&gt;0)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!((e=String(e)).length&gt;100)){var o=<span class="cstat-no" title="statement not covered" >/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(o){var i=<span class="cstat-no" title="statement not covered" >parseFloat(o[1]);<span class="cstat-no" title="statement not covered" ></span>switch((o[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":<span class="cstat-no" title="statement not covered" >return 315576e5*i;c</span>ase"weeks":case"week":case"w":<span class="cstat-no" title="statement not covered" >return 6048e5*i;c</span>ase"days":case"day":case"d":<span class="cstat-no" title="statement not covered" >return i*s;c</span>ase"hours":case"hour":case"hrs":case"hr":case"h":<span class="cstat-no" title="statement not covered" >return i*r;c</span>ase"minutes":case"minute":case"mins":case"min":case"m":<span class="cstat-no" title="statement not covered" >return i*n;c</span>ase"seconds":case"second":case"secs":case"sec":case"s":<span class="cstat-no" title="statement not covered" >return i*t;c</span>ase"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":<span class="cstat-no" title="statement not covered" >return i;d</span>efault:<span class="cstat-no" title="statement not covered" >return}</span>}</span>}</span>}</span>(e);<span class="cstat-no" title="statement not covered" >i</span></span>f("number"===u&amp;&amp;isFinite(e))<span class="cstat-no" title="statement not covered" >return i.long?(a=e,(c=Math.abs(a))&gt;=s?o(a,c,s,"day"):c&gt;=r?o(a,c,r,"hour"):c&gt;=n?o(a,c,n,"minute"):c&gt;=t?o(a,c,t,"second"):a+" ms"):<span class="fstat-no" title="function not covered" >fu</span>nction(e){var o=<span class="cstat-no" title="statement not covered" >Math.abs(e);<span class="cstat-no" title="statement not covered" ></span>return o&gt;=s?Math.round(e/s)+"d":o&gt;=r?Math.round(e/r)+"h":o&gt;=n?Math.round(e/n)+"m":o&gt;=t?Math.round(e/t)+"s":e+"ms"}</span>(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}</span>}</span>,3300:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";var n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof self)<span class="cstat-no" title="statement not covered" >return self;<span class="cstat-no" title="statement not covered" >i</span></span>f("undefined"!=typeof window)<span class="cstat-no" title="statement not covered" >return window;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==n)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("unable to locate global object")}</span>();<span class="cstat-no" title="statement not covered" ></span>e.exports=t=n.fetch,n.fetch&amp;&amp;(t.default=n.fetch.bind(n)),t.Headers=n.Headers,t.Request=n.Request,t.Response=n.Response}</span>,6898:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";var n;<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.Speed=void 0,(n=t.Speed||(t.Speed={})).good="GOOD",n.ok="OK",n.bad="BAD",n.nothing="NOTHING"}</span>,14:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";var n;<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.BandwidthMode=void 0,(n=t.BandwidthMode||(t.BandwidthMode={})).big="big",n.small="small"}</span>,9623:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r,s=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__extends||(r=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(e[n]=t[n])}</span></span>,r(e,t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t&amp;&amp;null!==t)<span class="cstat-no" title="statement not covered" >throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");f</span></span>unction <span class="fstat-no" title="function not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >this.constructor=e}<span class="cstat-no" title="statement not covered" ></span>r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}</span>),</span>o=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__assign||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o=Object.assign||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,n=<span class="cstat-no" title="statement not covered" >1,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length;</span>n&lt;r;n++)<span class="cstat-no" title="statement not covered" >for(var s in t=arguments[n])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,s)&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>,o.apply(this,arguments)}</span>,</span>i=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__awaiter||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >return new(n||(n=Promise))((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(r.next(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(r.throw(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){var t;<span class="cstat-no" title="statement not covered" >e.done?s(e.value):(t=e.value,t instanceof n?t:new n((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(t)}</span>))).then(i,a)}<span class="cstat-no" title="statement not covered" ></span>c((r=r.apply(e,t||[])).next())}</span>))}</span>,</span>a=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__generator||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n,r,s,o,i=<span class="cstat-no" title="statement not covered" >{label:0,sent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(1&amp;s[0])<span class="cstat-no" title="statement not covered" >throw s[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s[1]}</span>,trys:[],ops:[]};<span class="cstat-no" title="statement not covered" ></span>return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&amp;&amp;(o[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>),o;f</span>unction <span class="fstat-no" title="function not covered" >a(</span>o){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Generator is already executing.");<span class="cstat-no" title="statement not covered" >f</span></span>or(;i;)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(n=1,r&amp;&amp;(s=2&amp;o[0]?r.return:o[0]?r.throw||((s=r.return)&amp;&amp;s.call(r),0):r.next)&amp;&amp;!(s=s.call(r,o[1])).done)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>witch(r=0,s&amp;&amp;(o=[2&amp;o[0],s.value]),o[0]){case 0:case 1:<span class="cstat-no" title="statement not covered" >s=o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return i.label++,{value:o[1],done:!1};c</span>ase 5:<span class="cstat-no" title="statement not covered" >i.label++,r=o[1],o=[0];<span class="cstat-no" title="statement not covered" >c</span>ontinue;c</span>ase 7:<span class="cstat-no" title="statement not covered" >o=i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;d</span>efault:<span class="cstat-no" title="statement not covered" >if(!((s=(s=i.trys).length&gt;0&amp;&amp;s[s.length-1])||6!==o[0]&amp;&amp;2!==o[0])){<span class="cstat-no" title="statement not covered" >i=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(3===o[0]&amp;&amp;(!s||o[1]&gt;s[0]&amp;&amp;o[1]&lt;s[3])){<span class="cstat-no" title="statement not covered" >i.label=o[1];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(6===o[0]&amp;&amp;i.label&lt;s[1]){<span class="cstat-no" title="statement not covered" >i.label=s[1],s=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s&amp;&amp;i.label&lt;s[2]){<span class="cstat-no" title="statement not covered" >i.label=s[2],i.ops.push(o);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>[2]&amp;&amp;i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>o</span>=t.call(e,i)}</span>catch(e){<span class="cstat-no" title="statement not covered" >o=[6,e],r=0}</span>finally{<span class="cstat-no" title="statement not covered" >n=s=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(5&amp;o[0])<span class="cstat-no" title="statement not covered" >throw o[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o[0]?o[1]:void 0,done:!0}}</span>([o,a])}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.CCT=void 0;v</span>ar c=<span class="cstat-no" title="statement not covered" >n(7429),</span>u=<span class="cstat-no" title="statement not covered" >n(3300),</span>l=<span class="cstat-no" title="statement not covered" >n(7187),</span>h=<span class="cstat-no" title="statement not covered" >n(7046),</span>d=<span class="cstat-no" title="statement not covered" >n(8599),</span>f=<span class="cstat-no" title="statement not covered" >n(6898),</span>p=<span class="cstat-no" title="statement not covered" >n(5940),</span>y=<span class="cstat-no" title="statement not covered" >n(8944),</span>g=<span class="cstat-no" title="statement not covered" >{reconnection:!1,timeout:5e3},</span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){function <span class="fstat-no" title="function not covered" >t(</span>){var t=<span class="cstat-no" title="statement not covered" >e.call(this)||this;<span class="cstat-no" title="statement not covered" ></span>return t.allDatacenters=[],t.datacenters=[],t.runningLatency=!1,t.runningBandwidth=!1,t.idsToExclude=[],t.compatibleDCsWithSockets=[],t.lce=new p.LCE,t.abortControllers=[],t.sockets={latency:null,bandwidth:null},t.measurementConfigs={latency:{type:"latency",socketStartEvent:"latency:start",socketEndEvent:"latency:end",socketIterationEvent:"latency:iteration",socketTickEvent:"latency",iterationEvent:"latency:iteration",tickEvent:"latency",endEvent:"latency:end",getMeasurementResult:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.lce.getLatencyFor(e)}</span>},bandwidth:{type:"bandwidth",socketStartEvent:"bandwidth:start",socketEndEvent:"bandwidth:end",socketIterationEvent:"bandwidth:iteration",socketTickEvent:"bandwidth",iterationEvent:"bandwidth:iteration",tickEvent:"bandwidth",endEvent:"bandwidth:end",getMeasurementResult:<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return t.lce.getBandwidthFor(e,n.bandwidthMode)}</span>}},t}<span class="cstat-no" title="statement not covered" ></span>return s(t,e),t.prototype.fetchDatacenterInformationRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.label){case 0:<span class="cstat-no" title="statement not covered" >return t.trys.push([0,2,,3]),[4,(0,u.default)(e).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.json()}</span>))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return[2,t.sent()];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return t.sent(),[2,[]];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return[2]}</span>}</span>))}</span>))}</span>,t.prototype.fetchDatacenterInformation=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >switch(n.label){case 0:<span class="cstat-no" title="statement not covered" >return t=this,[4,this.fetchDatacenterInformationRequest(e)];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return t.allDatacenters=n.sent(),this.datacenters=this.allDatacenters,this.clean(),[2]}</span>}</span>))}</span>))}</span>,t.prototype.fetchCompatibleDCsWithSockets=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >switch(n.label){case 0:<span class="cstat-no" title="statement not covered" >return[4,Promise.all(this.datacenters.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(t,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >switch(n.label){case 0:<span class="cstat-no" title="statement not covered" >return t={dc:e},[4,this.lce.checkIfCompatibleWithSockets(e.ip)];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return[2,(t.isCompatible=n.sent(),t)]}</span>}</span>))}</span>))}</span>)))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return e=n.sent(),this.compatibleDCsWithSockets=e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.isCompatible}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.dc}</span>)),[2,this.compatibleDCsWithSockets]}</span>}</span>))}</span>))}</span>,t.prototype.setFilters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.datacenters=e?this.allDatacenters.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return!t.idsToExclude.includes(n.id)&amp;&amp;Object.keys(e).every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"tags"===t?e[t].some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n[t].toLowerCase().includes(e.toLowerCase())}</span>)):e[t].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.toLowerCase()}</span>)).includes(n[t].toLowerCase())}</span>))}</span>)):this.allDatacenters.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!t.idsToExclude.includes(e.id)}</span>)),this.filters=e}</span>,t.prototype.stopMeasurements=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.runningLatency=!1,this.runningBandwidth=!1,this.abortControllers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.abort()}</span>)),this.abortControllers=[],this.lce.terminate(),this.emit("latency:end"),this.emit("bandwidth:end")}</span>,t.prototype.startLatencyChecks=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e={}),i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,n,r,s;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >return t=e.iterations,n=void 0===t?16:t,r=e.save,s=void 0===r||r,[4,this.startMeasurements("latency",o(o({},e),{iterations:n,save:s}),new d.default)];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return i.sent(),[2]}</span>}</span>))}</span>))}</span>,t.prototype.startBandwidthChecks=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e={}),i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,n,r,s;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >return t=e.iterations,n=void 0===t?4:t,r=e.save,s=void 0===r||r,[4,this.startMeasurements("bandwidth",o(o({},e),{iterations:n,save:s}),new d.default)];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return i.sent(),[2]}</span>}</span>))}</span>))}</span>,t.prototype.startMeasurements=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var r,s,o;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >return r=this.measurementConfigs[e],this[s="latency"===e?"runningLatency":"runningBandwidth"]=!0,this.abortControllers.push(n),(o=t.from&amp;&amp;this.allDatacenters.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.id===t.from}</span>)))?[4,this.startCloudMeasurements(r,t,o,n)]:[3,2];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return i.sent(),[3,4];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return 0===this.datacenters.length?[3,4]:[4,this.startLocalMeasurements(r,t,n)];c</span>ase 3:<span class="cstat-no" title="statement not covered" >i.sent(),i.label=4;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return n.signal.aborted||(this[s]=!1,this.emit(r.endEvent)),[2]}</span>}</span>))}</span>))}</span>,t.prototype.setIdToExclude=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.idsToExclude=e||[],this.setFilters(this.filters)}</span>,t.prototype.clearSocket=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.sockets[e];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(t.emit("stop"),t.removeAllListeners(),this.sockets[e]=null)}</span>,t.prototype.startCloudMeasurements=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return y.Util.isBackEnd()?[2]:[2,new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i){var a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s.clearSocket(e.type),i()}</span>;<span class="cstat-no" title="statement not covered" ></span>r.signal.addEventListener("abort",a);v</span>ar c=<span class="cstat-no" title="statement not covered" >(0,h.io)("ws://localhost",o(o({},g),{query:{id:n.id}}));<span class="cstat-no" title="statement not covered" ></span>console.log(c),s.sockets[e.type]=c,[e.socketEndEvent,"disconnect","connect_error"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return c.on(e,a)}</span>)),c.on("connect",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >c.emit(e.socketStartEvent,o(o({},t),{id:n.id,filters:s.filters}))}</span>)),c.on(e.socketIterationEvent,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >s.emit(e.iterationEvent,t)}</span>)),c.on(e.socketTickEvent,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >s.handleEventData(n,t.save,e.type),s.emit(e.tickEvent,n)}</span>))}</span>))]}</span>))}</span>))}</span>,t.prototype.startLocalMeasurements=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var r,s,o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >r=t.iterations,i.label=1;c</span>ase 1:<span class="cstat-no" title="statement not covered" >return r-- &gt;0?n.signal.aborted?[2]:[4,Promise.all(this.datacenters.map((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return o.startMeasurementFor(e,r,t,n)}</span>)))]:[3,5];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return s=i.sent().filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!==e}</span>)),n.signal.aborted?[2]:(this.emit(e.iterationEvent,s),t.interval?[4,y.Util.sleep(t.interval,n)]:[3,4]);c</span>ase 3:<span class="cstat-no" title="statement not covered" >i.sent(),i.label=4;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return[3,1];c</span>ase 5:<span class="cstat-no" title="statement not covered" >return[2]}</span>}</span>))}</span>))}</span>,t.prototype.startMeasurementFor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var s,o;<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >return[4,e.getMeasurementResult(t,n)];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return s=i.sent(),r.signal.aborted||null===s?[2,null]:(o={id:t.id,data:s},this.handleEventData(o,n.save,e.type),this.emit(e.tickEvent,o),[2,o])}</span>}</span>))}</span>))}</span>,t.prototype.handleEventData=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.id,</span>s=<span class="cstat-no" title="statement not covered" >e.data;<span class="cstat-no" title="statement not covered" ></span>if(t){var o=<span class="cstat-no" title="statement not covered" >this.datacenters.findIndex((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.id===r}</span>));<span class="cstat-no" title="statement not covered" ></span>if(!(o&lt;0)){var i=<span class="cstat-no" title="statement not covered" >this.datacenters[o];<span class="cstat-no" title="statement not covered" ></span>if("latency"===n){<span class="cstat-no" title="statement not covered" >i.latencies=i.latencies||[],i.latencies.push(s);v</span>ar a=<span class="cstat-no" title="statement not covered" >y.Util.getAverageLatency(i.latencies);<span class="cstat-no" title="statement not covered" ></span>i.averageLatency=a,i.latencyJudgement=y.Util.judgeLatency(a)}</span>else <span class="cstat-no" title="statement not covered" >if("bandwidth"===n){<span class="cstat-no" title="statement not covered" >i.bandwidths=i.bandwidths||[],i.bandwidths.push(s);v</span>ar c=<span class="cstat-no" title="statement not covered" >y.Util.getAverageBandwidth(i.bandwidths);<span class="cstat-no" title="statement not covered" ></span>i.averageBandwidth=c,i.bandwidthJudgement=y.Util.judgeBandwidth(c)}</span>}</span></span>}</span>}</span>,t.prototype.getCurrentDatacentersSorted=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return y.Util.sortDatacenters(this.datacenters),this.datacenters}</span>,t.prototype.getAddress=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e={address:"",latitude:0,longitude:0},[2,new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >navigator&amp;&amp;(null===navigator||void 0===navigator?void 0:navigator.geolocation)?navigator.geolocation.getCurrentPosition((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return i(t,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.label){case 0:<span class="cstat-no" title="statement not covered" >return e.latitude=r.coords.latitude,e.longitude=r.coords.longitude,[4,(new google.maps.Geocoder).geocode({location:new google.maps.LatLng(e.latitude,e.longitude)},(<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >"OK"===r?(e.address=t[0].formatted_address,n(e)):(e.address="",e.latitude=0,e.longitude=0,n(e))}</span>))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return t.sent(),[2]}</span>}</span>))}</span>))}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n(e)}</span>)):n(e)}</span>))]}</span>))}</span>))}</span>,t.prototype.storeRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[2,(0,u.default)("https://cct.demo-education.cloud.sap/measurement",{method:"post",body:e,headers:{"Content-Type":"application/json"}}).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.json()}</span>))]}</span>))}</span>))}</span>,t.prototype.store=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,n,r,s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return a(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >switch(i.label){case 0:<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return[2,!1];<span class="cstat-no" title="statement not covered" >i</span></span>f(t=[],this.datacenters.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(e.latencies.length-(e.storedLatencyCount||0)&gt;=16){var r=<span class="cstat-no" title="statement not covered" >y.Util.getAverageLatency(e.latencies,e.storedLatencyCount),</span>o=<span class="cstat-no" title="statement not covered" >y.Util.getAverageBandwidth(e.bandwidths,e.storedBandwidthCount);<span class="cstat-no" title="statement not covered" ></span>t.push({id:e.id,latency:r.toFixed(2),averageBandwidth:o.megaBitsPerSecond.toFixed(2)}),s.datacenters[n].storedLatencyCount=e.latencies.length,s.datacenters[n].storedBandwidthCount=e.bandwidths.length}</span>}</span>)),0===t.length)<span class="cstat-no" title="statement not covered" >return[2,!1];<span class="cstat-no" title="statement not covered" >n</span></span>=o(o({uid:(0,c.v4)()},e),{data:t}),r=JSON.stringify(n,null,4),i.label=1;c</span>ase 1:<span class="cstat-no" title="statement not covered" >return i.trys.push([1,3,,4]),[4,this.storeRequest(r)];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return[2,"OK"===i.sent().status];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return i.sent(),[2,!1];c</span>ase 4:<span class="cstat-no" title="statement not covered" >return[2]}</span>}</span>))}</span>))}</span>,t.prototype.clean=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.datacenters.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.position=0,e.averageLatency=0,e.averageBandwidth={bitsPerSecond:0,kiloBitsPerSecond:0,megaBitsPerSecond:0},e.latencies=[],e.bandwidths=[],e.bandwidthJudgement=f.Speed.nothing,e.latencyJudgement=f.Speed.nothing,e.storedBandwidthCount=0,e.storedLatencyCount=0}</span>))}</span>,t}</span>(l.EventEmitter);<span class="cstat-no" title="statement not covered" ></span>t.CCT=v}</span>,5940:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__awaiter||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >return new(n||(n=Promise))((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(r.next(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(r.throw(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){var t;<span class="cstat-no" title="statement not covered" >e.done?s(e.value):(t=e.value,t instanceof n?t:new n((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(t)}</span>))).then(i,a)}<span class="cstat-no" title="statement not covered" ></span>c((r=r.apply(e,t||[])).next())}</span>))}</span>,</span>s=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__generator||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n,r,s,o,i=<span class="cstat-no" title="statement not covered" >{label:0,sent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(1&amp;s[0])<span class="cstat-no" title="statement not covered" >throw s[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s[1]}</span>,trys:[],ops:[]};<span class="cstat-no" title="statement not covered" ></span>return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&amp;&amp;(o[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>),o;f</span>unction <span class="fstat-no" title="function not covered" >a(</span>o){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Generator is already executing.");<span class="cstat-no" title="statement not covered" >f</span></span>or(;i;)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(n=1,r&amp;&amp;(s=2&amp;o[0]?r.return:o[0]?r.throw||((s=r.return)&amp;&amp;s.call(r),0):r.next)&amp;&amp;!(s=s.call(r,o[1])).done)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>witch(r=0,s&amp;&amp;(o=[2&amp;o[0],s.value]),o[0]){case 0:case 1:<span class="cstat-no" title="statement not covered" >s=o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return i.label++,{value:o[1],done:!1};c</span>ase 5:<span class="cstat-no" title="statement not covered" >i.label++,r=o[1],o=[0];<span class="cstat-no" title="statement not covered" >c</span>ontinue;c</span>ase 7:<span class="cstat-no" title="statement not covered" >o=i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;d</span>efault:<span class="cstat-no" title="statement not covered" >if(!((s=(s=i.trys).length&gt;0&amp;&amp;s[s.length-1])||6!==o[0]&amp;&amp;2!==o[0])){<span class="cstat-no" title="statement not covered" >i=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(3===o[0]&amp;&amp;(!s||o[1]&gt;s[0]&amp;&amp;o[1]&lt;s[3])){<span class="cstat-no" title="statement not covered" >i.label=o[1];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(6===o[0]&amp;&amp;i.label&lt;s[1]){<span class="cstat-no" title="statement not covered" >i.label=s[1],s=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s&amp;&amp;i.label&lt;s[2]){<span class="cstat-no" title="statement not covered" >i.label=s[2],i.ops.push(o);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>[2]&amp;&amp;i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>o</span>=t.call(e,i)}</span>catch(e){<span class="cstat-no" title="statement not covered" >o=[6,e],r=0}</span>finally{<span class="cstat-no" title="statement not covered" >n=s=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(5&amp;o[0])<span class="cstat-no" title="statement not covered" >throw o[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o[0]?o[1]:void 0,done:!0}}</span>([o,a])}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.LCE=void 0;v</span>ar o=<span class="cstat-no" title="statement not covered" >n(3300),</span>i=<span class="cstat-no" title="statement not covered" >n(8599),</span>a=<span class="cstat-no" title="statement not covered" >n(14),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >this.cancelableLatencyRequests=[],this.cancelableBandwidthRequests=[]}<span class="cstat-no" title="statement not covered" ></span>return e.prototype.checkIfCompatibleWithSockets=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,n;<span class="cstat-no" title="statement not covered" >return s(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >switch(r.label){case 0:<span class="cstat-no" title="statement not covered" >return r.trys.push([0,2,,3]),[4,this.latencyFetch("https://".concat(e,"/drone/index.html"))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return t=r.sent(),(n=null==t?void 0:t.headers.get("drone-version"))?[2,this.isSemverVersionHigher(n)]:[2,!1];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return r.sent(),[2,!1];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return[2]}</span>}</span>))}</span>))}</span>,e.prototype.getLatencyFor=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >return s(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >switch(n.label){case 0:<span class="cstat-no" title="statement not covered" >return t=Date.now(),[4,this.latencyFetch("https://".concat(e.ip,"/drone/index.html"))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return n.sent(),[2,{value:Date.now()-t,timestamp:Date.now()}]}</span>}</span>))}</span>))}</span>,e.prototype.getBandwidthFor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=a.BandwidthMode.big),r(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var n,r,o,i,a;<span class="cstat-no" title="statement not covered" >return s(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >switch(s.label){case 0:<span class="cstat-no" title="statement not covered" >return n=Date.now(),[4,this.bandwidthFetch("https://".concat(e.ip,"/drone/").concat(t))];c</span>ase 1:<span class="cstat-no" title="statement not covered" >if(r=s.sent(),o=Date.now(),null===r)<span class="cstat-no" title="statement not covered" >return[3,6];<span class="cstat-no" title="statement not covered" >i</span></span>=void 0,s.label=2;c</span>ase 2:<span class="cstat-no" title="statement not covered" >return s.trys.push([2,4,,5]),[4,r.text()];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return i=s.sent(),[3,5];c</span>ase 4:<span class="cstat-no" title="statement not covered" >return a=s.sent(),console.log(a),[2,null];c</span>ase 5:<span class="cstat-no" title="statement not covered" >return[2,{value:this.calcBandwidth(i.length,o-n),timestamp:Date.now()}];c</span>ase 6:<span class="cstat-no" title="statement not covered" >return[2,null]}</span>}</span>))}</span>))}</span>,e.prototype.bandwidthFetch=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >new i.default;<span class="cstat-no" title="statement not covered" ></span>return this.cancelableBandwidthRequests.push(t),this.abortableFetch(e,t)}</span>,e.prototype.latencyFetch=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >new i.default;<span class="cstat-no" title="statement not covered" ></span>return this.cancelableLatencyRequests.push(t),this.abortableFetch(e,t)}</span>,e.prototype.abortableFetch=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return void 0===n&amp;&amp;(n=3e3),r(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var r,i,a,c;<span class="cstat-no" title="statement not covered" >return s(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >switch(s.label){case 0:<span class="cstat-no" title="statement not covered" >r=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.abort()}</span>),n),s.label=1;c</span>ase 1:<span class="cstat-no" title="statement not covered" >return s.trys.push([1,3,,4]),i=new URLSearchParams({t:"".concat(Date.now())}).toString(),[4,(0,o.default)("".concat(e,"?").concat(i),{signal:t.signal})];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return a=s.sent(),clearTimeout(r),[2,a];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return c=s.sent(),console.log(c),clearTimeout(r),[2,null];c</span>ase 4:<span class="cstat-no" title="statement not covered" >return[2]}</span>}</span>))}</span>))}</span>,e.prototype.compare=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.latency&lt;t.latency?-1:e.latency&gt;t.latency?1:0}</span>,e.prototype.terminate=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.cancelableLatencyRequests.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.abort()}</span>)),this.cancelableBandwidthRequests.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.abort()}</span>)),this.cancelableLatencyRequests=[],this.cancelableBandwidthRequests=[]}</span>,e.prototype.calcBandwidth=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n=<span class="cstat-no" title="statement not covered" >8*e/(t/1e3),</span>r=<span class="cstat-no" title="statement not covered" >n/1e3;<span class="cstat-no" title="statement not covered" ></span>return{bitsPerSecond:n,kiloBitsPerSecond:r,megaBitsPerSecond:r/1e3}}</span>,e.prototype.isSemverVersionHigher=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t="3.0.0");<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >e.split(".").map(Number),</span>r=<span class="cstat-no" title="statement not covered" >t.split(".").map(Number),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;3;s++){<span class="cstat-no" title="statement not covered" >if(n[s]&gt;r[s])<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(n[s]&lt;r[s])<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>,e}</span>();<span class="cstat-no" title="statement not covered" ></span>t.LCE=c}</span>,8944:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.Util=void 0;v</span>ar r=<span class="cstat-no" title="statement not covered" >n(6898),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >e(</span>){}<span class="cstat-no" title="statement not covered" >return e.isBackEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return"[object process]"===Object.prototype.toString.call(n.g.process)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>,e.getAverageLatency=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;(t=0),!e||0===e.length||t&gt;=e.length)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.slice(t);<span class="cstat-no" title="statement not covered" ></span>return n.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e+t.value}</span>),0)/n.length}</span>,e.getAverageBandwidth=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;(t=0),!e||0===e.length||t&gt;=e.length)<span class="cstat-no" title="statement not covered" >return{bitsPerSecond:-1,kiloBitsPerSecond:-1,megaBitsPerSecond:-1};v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.slice(t),</span>r=<span class="cstat-no" title="statement not covered" >n.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{bitsPerSecond:e.bitsPerSecond+t.value.bitsPerSecond,kiloBitsPerSecond:e.kiloBitsPerSecond+t.value.kiloBitsPerSecond,megaBitsPerSecond:e.megaBitsPerSecond+t.value.megaBitsPerSecond}}</span>),{bitsPerSecond:0,kiloBitsPerSecond:0,megaBitsPerSecond:0}),</span>s=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>return{bitsPerSecond:r.bitsPerSecond/s,kiloBitsPerSecond:r.kiloBitsPerSecond/s,megaBitsPerSecond:r.megaBitsPerSecond/s}}</span>,e.sortDatacenters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.averageLatency-t.averageLatency}</span>)),e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.position=t+1}</span>)),e}</span>,e.getTop3=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.sortDatacenters(t).slice(0,3)}</span>,e.sleep=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n=<span class="cstat-no" title="statement not covered" >t.signal;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var s=<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t()}</span>),e);<span class="cstat-no" title="statement not covered" ></span>n.addEventListener("abort",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >clearTimeout(s),t()}</span>))}</span>))}</span>,e.judgeLatency=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&lt;170?r.Speed.good:e&gt;=170&amp;&amp;e&lt;280?r.Speed.ok:r.Speed.bad}</span>,e.judgeBandwidth=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.megaBitsPerSecond&gt;1?r.Speed.good:e.megaBitsPerSecond&lt;=1&amp;&amp;e.megaBitsPerSecond&gt;.3?r.Speed.ok:r.Speed.bad}</span>,e}</span>();<span class="cstat-no" title="statement not covered" ></span>t.Util=s}</span>,7429:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"NIL",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.default}</span>}),Object.defineProperty(t,"parse",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return h.default}</span>}),Object.defineProperty(t,"stringify",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.default}</span>}),Object.defineProperty(t,"v1",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r.default}</span>}),Object.defineProperty(t,"v3",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.default}</span>}),Object.defineProperty(t,"v4",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.default}</span>}),Object.defineProperty(t,"v5",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.default}</span>}),Object.defineProperty(t,"validate",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return u.default}</span>}),Object.defineProperty(t,"version",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c.default}</span>});v</span>ar r=<span class="cstat-no" title="statement not covered" >d(n(3990)),</span>s=<span class="cstat-no" title="statement not covered" >d(n(8237)),</span>o=<span class="cstat-no" title="statement not covered" >d(n(5355)),</span>i=<span class="cstat-no" title="statement not covered" >d(n(3764)),</span>a=<span class="cstat-no" title="statement not covered" >d(n(6314)),</span>c=<span class="cstat-no" title="statement not covered" >d(n(8464)),</span>u=<span class="cstat-no" title="statement not covered" >d(n(6435)),</span>l=<span class="cstat-no" title="statement not covered" >d(n(4008)),</span>h=<span class="cstat-no" title="statement not covered" >d(n(8222));</span>function <span class="fstat-no" title="function not covered" >d(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>},4163:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";function <span class="fstat-no" title="function not covered" >n(</span>e){<span class="cstat-no" title="statement not covered" >return 14+(e+64&gt;&gt;&gt;9&lt;&lt;4)+1}</span>function <span class="fstat-no" title="function not covered" >r(</span>e,t){const n=<span class="cstat-no" title="statement not covered" >(65535&amp;e)+(65535&amp;t);<span class="cstat-no" title="statement not covered" ></span>return(e&gt;&gt;16)+(t&gt;&gt;16)+(n&gt;&gt;16)&lt;&lt;16|65535&amp;n}</span>function <span class="fstat-no" title="function not covered" >s(</span>e,t,n,s,o,i){<span class="cstat-no" title="statement not covered" >return r((a=r(r(t,e),r(s,i)))&lt;&lt;(c=o)|a&gt;&gt;&gt;32-c,n);v</span>ar a,c}function <span class="fstat-no" title="function not covered" >o(</span>e,t,n,r,o,i,a){<span class="cstat-no" title="statement not covered" >return s(t&amp;n|~t&amp;r,e,t,o,i,a)}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,t,n,r,o,i,a){<span class="cstat-no" title="statement not covered" >return s(t&amp;r|n&amp;~r,e,t,o,i,a)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t,n,r,o,i,a){<span class="cstat-no" title="statement not covered" >return s(t^n^r,e,t,o,i,a)}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t,n,r,o,i,a){<span class="cstat-no" title="statement not covered" >return s(n^(t|~r),e,t,o,i,a)}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;<span class="cstat-no" title="statement not covered" >t</span>.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("string"==typeof e){const t=<span class="cstat-no" title="statement not covered" >unescape(encodeURIComponent(e));<span class="cstat-no" title="statement not covered" ></span>e=new Uint8Array(t.length);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >e[n]=t.charCodeAt(n)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >32*e.length,</span>r=<span class="cstat-no" title="statement not covered" >"0123456789abcdef";<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;n;s+=8){const n=<span class="cstat-no" title="statement not covered" >e[s&gt;&gt;5]&gt;&gt;&gt;s%32&amp;255,</span>o=<span class="cstat-no" title="statement not covered" >parseInt(r.charAt(n&gt;&gt;&gt;4&amp;15)+r.charAt(15&amp;n),16);<span class="cstat-no" title="statement not covered" ></span>t.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e[t&gt;&gt;5]|=128&lt;&lt;t%32,e[n(t)-1]=t;l</span>et s=<span class="cstat-no" title="statement not covered" >1732584193,</span>u=<span class="cstat-no" title="statement not covered" >-271733879,</span>l=<span class="cstat-no" title="statement not covered" >-1732584194,</span>h=<span class="cstat-no" title="statement not covered" >271733878;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t+=16){const n=<span class="cstat-no" title="statement not covered" >s,</span>d=<span class="cstat-no" title="statement not covered" >u,</span>f=<span class="cstat-no" title="statement not covered" >l,</span>p=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>s=o(s,u,l,h,e[t],7,-680876936),h=o(h,s,u,l,e[t+1],12,-389564586),l=o(l,h,s,u,e[t+2],17,606105819),u=o(u,l,h,s,e[t+3],22,-1044525330),s=o(s,u,l,h,e[t+4],7,-176418897),h=o(h,s,u,l,e[t+5],12,1200080426),l=o(l,h,s,u,e[t+6],17,-1473231341),u=o(u,l,h,s,e[t+7],22,-45705983),s=o(s,u,l,h,e[t+8],7,1770035416),h=o(h,s,u,l,e[t+9],12,-1958414417),l=o(l,h,s,u,e[t+10],17,-42063),u=o(u,l,h,s,e[t+11],22,-1990404162),s=o(s,u,l,h,e[t+12],7,1804603682),h=o(h,s,u,l,e[t+13],12,-40341101),l=o(l,h,s,u,e[t+14],17,-1502002290),u=o(u,l,h,s,e[t+15],22,1236535329),s=i(s,u,l,h,e[t+1],5,-165796510),h=i(h,s,u,l,e[t+6],9,-1069501632),l=i(l,h,s,u,e[t+11],14,643717713),u=i(u,l,h,s,e[t],20,-373897302),s=i(s,u,l,h,e[t+5],5,-701558691),h=i(h,s,u,l,e[t+10],9,38016083),l=i(l,h,s,u,e[t+15],14,-660478335),u=i(u,l,h,s,e[t+4],20,-405537848),s=i(s,u,l,h,e[t+9],5,568446438),h=i(h,s,u,l,e[t+14],9,-1019803690),l=i(l,h,s,u,e[t+3],14,-187363961),u=i(u,l,h,s,e[t+8],20,1163531501),s=i(s,u,l,h,e[t+13],5,-1444681467),h=i(h,s,u,l,e[t+2],9,-51403784),l=i(l,h,s,u,e[t+7],14,1735328473),u=i(u,l,h,s,e[t+12],20,-1926607734),s=a(s,u,l,h,e[t+5],4,-378558),h=a(h,s,u,l,e[t+8],11,-2022574463),l=a(l,h,s,u,e[t+11],16,1839030562),u=a(u,l,h,s,e[t+14],23,-35309556),s=a(s,u,l,h,e[t+1],4,-1530992060),h=a(h,s,u,l,e[t+4],11,1272893353),l=a(l,h,s,u,e[t+7],16,-155497632),u=a(u,l,h,s,e[t+10],23,-1094730640),s=a(s,u,l,h,e[t+13],4,681279174),h=a(h,s,u,l,e[t],11,-358537222),l=a(l,h,s,u,e[t+3],16,-722521979),u=a(u,l,h,s,e[t+6],23,76029189),s=a(s,u,l,h,e[t+9],4,-640364487),h=a(h,s,u,l,e[t+12],11,-421815835),l=a(l,h,s,u,e[t+15],16,530742520),u=a(u,l,h,s,e[t+2],23,-995338651),s=c(s,u,l,h,e[t],6,-198630844),h=c(h,s,u,l,e[t+7],10,1126891415),l=c(l,h,s,u,e[t+14],15,-1416354905),u=c(u,l,h,s,e[t+5],21,-57434055),s=c(s,u,l,h,e[t+12],6,1700485571),h=c(h,s,u,l,e[t+3],10,-1894986606),l=c(l,h,s,u,e[t+10],15,-1051523),u=c(u,l,h,s,e[t+1],21,-2054922799),s=c(s,u,l,h,e[t+8],6,1873313359),h=c(h,s,u,l,e[t+15],10,-30611744),l=c(l,h,s,u,e[t+6],15,-1560198380),u=c(u,l,h,s,e[t+13],21,1309151649),s=c(s,u,l,h,e[t+4],6,-145523070),h=c(h,s,u,l,e[t+11],10,-1120210379),l=c(l,h,s,u,e[t+2],15,718787259),u=c(u,l,h,s,e[t+9],21,-343485551),s=r(s,n),u=r(u,d),l=r(l,f),h=r(h,p)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[s,u,l,h]}</span>(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(0===e.length)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst t=<span class="cstat-no" title="statement not covered" >8*e.length,</span>r=<span class="cstat-no" title="statement not covered" >new Uint32Array(n(t));<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t;n+=8)<span class="cstat-no" title="statement not covered" >r[n&gt;&gt;5]|=(255&amp;e[n/8])&lt;&lt;n%32;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>(e),8*e.length))}</span>}</span>,4790:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >{randomUUID:"undefined"!=typeof crypto&amp;&amp;crypto.randomUUID&amp;&amp;crypto.randomUUID.bind(crypto)};<span class="cstat-no" title="statement not covered" ></span>t.default=n}</span>,6314:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default="00000000-0000-0000-0000-000000000000"}</span>,8222:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >(r=n(6435))&amp;&amp;r.__esModule?r:{default:r};<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!(0,s.default)(e))<span class="cstat-no" title="statement not covered" >throw TypeError("Invalid UUID");l</span></span>et t;const n=<span class="cstat-no" title="statement not covered" >new Uint8Array(16);<span class="cstat-no" title="statement not covered" ></span>return n[0]=(t=parseInt(e.slice(0,8),16))&gt;&gt;&gt;24,n[1]=t&gt;&gt;&gt;16&amp;255,n[2]=t&gt;&gt;&gt;8&amp;255,n[3]=255&amp;t,n[4]=(t=parseInt(e.slice(9,13),16))&gt;&gt;&gt;8,n[5]=255&amp;t,n[6]=(t=parseInt(e.slice(14,18),16))&gt;&gt;&gt;8,n[7]=255&amp;t,n[8]=(t=parseInt(e.slice(19,23),16))&gt;&gt;&gt;8,n[9]=255&amp;t,n[10]=(t=parseInt(e.slice(24,36),16))/1099511627776&amp;255,n[11]=t/4294967296&amp;255,n[12]=t&gt;&gt;&gt;24&amp;255,n[13]=t&gt;&gt;&gt;16&amp;255,n[14]=t&gt;&gt;&gt;8&amp;255,n[15]=255&amp;t,n}</span>}</span>,58:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i}</span>,3319:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";let n;<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!n&amp;&amp;(n="undefined"!=typeof crypto&amp;&amp;crypto.getRandomValues&amp;&amp;crypto.getRandomValues.bind(crypto),!n))<span class="cstat-no" title="statement not covered" >throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n(r)}</span>;c</span>onst r=<span class="cstat-no" title="statement not covered" >new Uint8Array(16)}</span>,3757:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";function <span class="fstat-no" title="function not covered" >n(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >switch(e){case 0:<span class="cstat-no" title="statement not covered" >return t&amp;n^~t&amp;r;c</span>ase 1:case 3:<span class="cstat-no" title="statement not covered" >return t^n^r;c</span>ase 2:<span class="cstat-no" title="statement not covered" >return t&amp;n^t&amp;r^n&amp;r}</span>}</span>function <span class="fstat-no" title="function not covered" >r(</span>e,t){<span class="cstat-no" title="statement not covered" >return e&lt;&lt;t|e&gt;&gt;&gt;32-t}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;<span class="cstat-no" title="statement not covered" >t</span>.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >[1518500249,1859775393,2400959708,3395469782],</span>s=<span class="cstat-no" title="statement not covered" >[1732584193,4023233417,2562383102,271733878,3285377520];<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof e){const t=<span class="cstat-no" title="statement not covered" >unescape(encodeURIComponent(e));<span class="cstat-no" title="statement not covered" ></span>e=[];<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >e.push(t.charCodeAt(n))}</span></span>else <span class="cstat-no" title="statement not covered" >Array.isArray(e)||(e=Array.prototype.slice.call(e));<span class="cstat-no" title="statement not covered" >e</span></span>.push(128);c</span>onst o=<span class="cstat-no" title="statement not covered" >e.length/4+2,</span>i=<span class="cstat-no" title="statement not covered" >Math.ceil(o/16),</span>a=<span class="cstat-no" title="statement not covered" >new Array(i);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i;++t){const n=<span class="cstat-no" title="statement not covered" >new Uint32Array(16);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;16;++r)<span class="cstat-no" title="statement not covered" >n[r]=e[64*t+4*r]&lt;&lt;24|e[64*t+4*r+1]&lt;&lt;16|e[64*t+4*r+2]&lt;&lt;8|e[64*t+4*r+3];<span class="cstat-no" title="statement not covered" >a</span></span>[t]=n}<span class="cstat-no" title="statement not covered" ></span>a</span>[i-1][14]=8*(e.length-1)/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=8*(e.length-1)&amp;4294967295;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;i;++e){const o=<span class="cstat-no" title="statement not covered" >new Uint32Array(80);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;16;++t)<span class="cstat-no" title="statement not covered" >o[t]=a[e][t];<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >16;</span>e&lt;80;++e)<span class="cstat-no" title="statement not covered" >o[e]=r(o[e-3]^o[e-8]^o[e-14]^o[e-16],1);l</span></span>et i=<span class="cstat-no" title="statement not covered" >s[0],</span>c=<span class="cstat-no" title="statement not covered" >s[1],</span>u=<span class="cstat-no" title="statement not covered" >s[2],</span>l=<span class="cstat-no" title="statement not covered" >s[3],</span>h=<span class="cstat-no" title="statement not covered" >s[4];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;80;++e){const s=<span class="cstat-no" title="statement not covered" >Math.floor(e/20),</span>a=<span class="cstat-no" title="statement not covered" >r(i,5)+n(s,c,u,l)+h+t[s]+o[e]&gt;&gt;&gt;0;<span class="cstat-no" title="statement not covered" ></span>h=l,l=u,u=r(c,30)&gt;&gt;&gt;0,c=i,i=a}<span class="cstat-no" title="statement not covered" ></span>s</span>[0]=s[0]+i&gt;&gt;&gt;0,s[1]=s[1]+c&gt;&gt;&gt;0,s[2]=s[2]+u&gt;&gt;&gt;0,s[3]=s[3]+l&gt;&gt;&gt;0,s[4]=s[4]+h&gt;&gt;&gt;0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[s[0]&gt;&gt;24&amp;255,s[0]&gt;&gt;16&amp;255,s[0]&gt;&gt;8&amp;255,255&amp;s[0],s[1]&gt;&gt;24&amp;255,s[1]&gt;&gt;16&amp;255,s[1]&gt;&gt;8&amp;255,255&amp;s[1],s[2]&gt;&gt;24&amp;255,s[2]&gt;&gt;16&amp;255,s[2]&gt;&gt;8&amp;255,255&amp;s[2],s[3]&gt;&gt;24&amp;255,s[3]&gt;&gt;16&amp;255,s[3]&gt;&gt;8&amp;255,255&amp;s[3],s[4]&gt;&gt;24&amp;255,s[4]&gt;&gt;16&amp;255,s[4]&gt;&gt;8&amp;255,255&amp;s[4]]}</span>}</span>,4008:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.unsafeStringify=i;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >(r=n(6435))&amp;&amp;r.__esModule?r:{default:r};</span>const o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;256;++e)<span class="cstat-no" title="statement not covered" >o.push((e+256).toString(16).slice(1));f</span></span>unction <span class="fstat-no" title="function not covered" >i(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return(o[e[t+0]]+o[e[t+1]]+o[e[t+2]]+o[e[t+3]]+"-"+o[e[t+4]]+o[e[t+5]]+"-"+o[e[t+6]]+o[e[t+7]]+"-"+o[e[t+8]]+o[e[t+9]]+"-"+o[e[t+10]]+o[e[t+11]]+o[e[t+12]]+o[e[t+13]]+o[e[t+14]]+o[e[t+15]]).toLowerCase()}<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{const n=<span class="cstat-no" title="statement not covered" >i(e,t);<span class="cstat-no" title="statement not covered" ></span>if(!(0,s.default)(n))<span class="cstat-no" title="statement not covered" >throw TypeError("Stringified UUID is invalid");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>}</span>,3990:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >(r=n(3319))&amp;&amp;r.__esModule?r:{default:r},</span>o=<span class="cstat-no" title="statement not covered" >n(4008);</span>let i,a,c=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){let r=<span class="cstat-no" title="statement not covered" >t&amp;&amp;n||0;</span>const l=<span class="cstat-no" title="statement not covered" >t||new Array(16);</span>let h=<span class="cstat-no" title="statement not covered" >(e=e||{}).node||i,</span>d=<span class="cstat-no" title="statement not covered" >void 0!==e.clockseq?e.clockseq:a;<span class="cstat-no" title="statement not covered" ></span>if(null==h||null==d){const t=<span class="cstat-no" title="statement not covered" >e.random||(e.rng||s.default)();<span class="cstat-no" title="statement not covered" ></span>null==h&amp;&amp;(h=i=[1|t[0],t[1],t[2],t[3],t[4],t[5]]),null==d&amp;&amp;(d=a=16383&amp;(t[6]&lt;&lt;8|t[7]))}</span>l</span>et f=<span class="cstat-no" title="statement not covered" >void 0!==e.msecs?e.msecs:Date.now(),</span>p=<span class="cstat-no" title="statement not covered" >void 0!==e.nsecs?e.nsecs:u+1;</span>const y=<span class="cstat-no" title="statement not covered" >f-c+(p-u)/1e4;<span class="cstat-no" title="statement not covered" ></span>if(y&lt;0&amp;&amp;void 0===e.clockseq&amp;&amp;(d=d+1&amp;16383),(y&lt;0||f&gt;c)&amp;&amp;void 0===e.nsecs&amp;&amp;(p=0),p&gt;=1e4)<span class="cstat-no" title="statement not covered" >throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");<span class="cstat-no" title="statement not covered" >c</span></span>=f,u=p,a=d,f+=122192928e5;c</span>onst g=<span class="cstat-no" title="statement not covered" >(1e4*(268435455&amp;f)+p)%4294967296;<span class="cstat-no" title="statement not covered" ></span>l[r++]=g&gt;&gt;&gt;24&amp;255,l[r++]=g&gt;&gt;&gt;16&amp;255,l[r++]=g&gt;&gt;&gt;8&amp;255,l[r++]=255&amp;g;c</span>onst v=<span class="cstat-no" title="statement not covered" >f/4294967296*1e4&amp;268435455;<span class="cstat-no" title="statement not covered" ></span>l[r++]=v&gt;&gt;&gt;8&amp;255,l[r++]=255&amp;v,l[r++]=v&gt;&gt;&gt;24&amp;15|16,l[r++]=v&gt;&gt;&gt;16&amp;255,l[r++]=d&gt;&gt;&gt;8|128,l[r++]=255&amp;d;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;6;++e)<span class="cstat-no" title="statement not covered" >l[r+e]=h[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t||(0,o.unsafeStringify)(l)}</span>}</span>,8237:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r=<span class="cstat-no" title="statement not covered" >o(n(7925)),</span>s=<span class="cstat-no" title="statement not covered" >o(n(4163));</span>function <span class="fstat-no" title="function not covered" >o(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>var i=<span class="cstat-no" title="statement not covered" >(0,r.default)("v3",48,s.default);<span class="cstat-no" title="statement not covered" ></span>t.default=i}</span>,7925:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.URL=t.DNS=void 0,t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){function <span class="fstat-no" title="function not covered" >r(</span>e,r,i,a){var c;<span class="cstat-no" title="statement not covered" >if("string"==typeof e&amp;&amp;(e=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e=unescape(encodeURIComponent(e));c</span>onst t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;++n)<span class="cstat-no" title="statement not covered" >t.push(e.charCodeAt(n));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>(e)),"string"==typeof r&amp;&amp;(r=(0,o.default)(r)),16!==(null===(c=r)||void 0===c?void 0:c.length))<span class="cstat-no" title="statement not covered" >throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");l</span></span>et u=<span class="cstat-no" title="statement not covered" >new Uint8Array(16+e.length);<span class="cstat-no" title="statement not covered" ></span>if(u.set(r),u.set(e,r.length),u=n(u),u[6]=15&amp;u[6]|t,u[8]=63&amp;u[8]|128,i){<span class="cstat-no" title="statement not covered" >a=a||0;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;16;++e)<span class="cstat-no" title="statement not covered" >i[a+e]=u[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(0,s.unsafeStringify)(u)}<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >r.name=e}</span>catch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn r.DNS=i,r.URL=a,r}</span>;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >n(4008),</span>o=<span class="cstat-no" title="statement not covered" >(r=n(8222))&amp;&amp;r.__esModule?r:{default:r};</span>const i=<span class="cstat-no" title="statement not covered" >"6ba7b810-9dad-11d1-80b4-00c04fd430c8";<span class="cstat-no" title="statement not covered" ></span>t.DNS=i;c</span>onst a=<span class="cstat-no" title="statement not covered" >"6ba7b811-9dad-11d1-80b4-00c04fd430c8";<span class="cstat-no" title="statement not covered" ></span>t.URL=a}</span>,5355:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r=<span class="cstat-no" title="statement not covered" >i(n(4790)),</span>s=<span class="cstat-no" title="statement not covered" >i(n(3319)),</span>o=<span class="cstat-no" title="statement not covered" >n(4008);</span>function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >if(r.default.randomUUID&amp;&amp;!t&amp;&amp;!e)<span class="cstat-no" title="statement not covered" >return r.default.randomUUID();c</span></span>onst i=<span class="cstat-no" title="statement not covered" >(e=e||{}).random||(e.rng||s.default)();<span class="cstat-no" title="statement not covered" ></span>if(i[6]=15&amp;i[6]|64,i[8]=63&amp;i[8]|128,t){<span class="cstat-no" title="statement not covered" >n=n||0;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;16;++e)<span class="cstat-no" title="statement not covered" >t[n+e]=i[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(0,o.unsafeStringify)(i)}</span>}</span>,3764:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r=<span class="cstat-no" title="statement not covered" >o(n(7925)),</span>s=<span class="cstat-no" title="statement not covered" >o(n(3757));</span>function <span class="fstat-no" title="function not covered" >o(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>var i=<span class="cstat-no" title="statement not covered" >(0,r.default)("v5",80,s.default);<span class="cstat-no" title="statement not covered" ></span>t.default=i}</span>,6435:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >(r=n(58))&amp;&amp;r.__esModule?r:{default:r};<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"string"==typeof e&amp;&amp;s.default.test(e)}</span>}</span>,8464:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;v</span>ar r,s=<span class="cstat-no" title="statement not covered" >(r=n(6435))&amp;&amp;r.__esModule?r:{default:r};<span class="cstat-no" title="statement not covered" ></span>t.default=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!(0,s.default)(e))<span class="cstat-no" title="statement not covered" >throw TypeError("Invalid UUID");<span class="cstat-no" title="statement not covered" >r</span></span>eturn parseInt(e.slice(14,15),16)}</span>}</span>,8419:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.hasCORS=void 0;l</span>et n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >n="undefined"!=typeof XMLHttpRequest&amp;&amp;"withCredentials"in new XMLHttpRequest}</span>catch(e){}<span class="cstat-no" title="statement not covered" >t</span>.hasCORS=n}</span>,5754:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=void 0,t.encode=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let n in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(n)&amp;&amp;(t.length&amp;&amp;(t+="&amp;"),t+=encodeURIComponent(n)+"="+encodeURIComponent(e[n]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,t.decode=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >e.split("&amp;");<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >n.length;</span>e&lt;r;e++){let r=<span class="cstat-no" title="statement not covered" >n[e].split("=");<span class="cstat-no" title="statement not covered" ></span>t[decodeURIComponent(r[0])]=decodeURIComponent(r[1])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}</span>,5222:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.parse=void 0;c</span>onst n=<span class="cstat-no" title="statement not covered" >/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,</span>r=<span class="cstat-no" title="statement not covered" >["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];<span class="cstat-no" title="statement not covered" ></span>t.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e.length&gt;2e3)<span class="cstat-no" title="statement not covered" >throw"URI too long";c</span></span>onst t=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >e.indexOf("["),</span>o=<span class="cstat-no" title="statement not covered" >e.indexOf("]");<span class="cstat-no" title="statement not covered" ></span>-1!=s&amp;&amp;-1!=o&amp;&amp;(e=e.substring(0,s)+e.substring(s,o).replace(/:/g,";")+e.substring(o,e.length));l</span>et i=<span class="cstat-no" title="statement not covered" >n.exec(e||""),</span>a=<span class="cstat-no" title="statement not covered" >{},</span>c=<span class="cstat-no" title="statement not covered" >14;<span class="cstat-no" title="statement not covered" ></span>for(;c--;)<span class="cstat-no" title="statement not covered" >a[r[c]]=i[c]||"";<span class="cstat-no" title="statement not covered" >r</span></span>eturn-1!=s&amp;&amp;-1!=o&amp;&amp;(a.source=t,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a.pathNames=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const n=<span class="cstat-no" title="statement not covered" >t.replace(/\/{2,9}/g,"/").split("/");<span class="cstat-no" title="statement not covered" ></span>return"/"!=t.slice(0,1)&amp;&amp;0!==t.length||n.splice(0,1),"/"==t.slice(-1)&amp;&amp;n.splice(n.length-1,1),n}</span>(0,a.path),a.queryKey=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.replace(/(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*)/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >t&amp;&amp;(n[t]=r)}</span>)),n}</span>(0,a.query),a}</span>}</span>,8726:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.yeast=t.decode=t.encode=void 0;c</span>onst n=<span class="cstat-no" title="statement not covered" >"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),</span>r=<span class="cstat-no" title="statement not covered" >{};</span>let s,o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >a(</span>e){let t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >t=n[e%64]+t,e=Math.floor(e/64)}</span>while(e&gt;0);<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="cstat-no" title="statement not covered" ></span>for(t.encode=a,t.decode=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;e.length;i++)<span class="cstat-no" title="statement not covered" >t=64*t+r[e.charAt(i)];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,t.yeast=<span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >a(+new Date);<span class="cstat-no" title="statement not covered" ></span>return e!==s?(o=0,s=e):e+"."+a(o++)}</span>;i&lt;64;i++)<span class="cstat-no" title="statement not covered" >r[n[i]]=i}</span></span>,6242:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.globalThisShim=void 0,t.globalThisShim="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")()}</span>,4679:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.nextTick=t.parse=t.installTimerFunctions=t.transports=t.TransportError=t.Transport=t.protocol=t.Socket=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(3481);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"Socket",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r.Socket}</span>}),t.protocol=r.Socket.protocol;v</span>ar s=<span class="cstat-no" title="statement not covered" >n(9870);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"Transport",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.Transport}</span>}),Object.defineProperty(t,"TransportError",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.TransportError}</span>});v</span>ar o=<span class="cstat-no" title="statement not covered" >n(7385);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"transports",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.transports}</span>});v</span>ar i=<span class="cstat-no" title="statement not covered" >n(9622);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"installTimerFunctions",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.installTimerFunctions}</span>});v</span>ar a=<span class="cstat-no" title="statement not covered" >n(5222);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"parse",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.parse}</span>});v</span>ar c=<span class="cstat-no" title="statement not covered" >n(5552);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"nextTick",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c.nextTick}</span>})}</span>,3481:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Socket=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(7385),</span>o=<span class="cstat-no" title="statement not covered" >n(9622),</span>i=<span class="cstat-no" title="statement not covered" >n(5754),</span>a=<span class="cstat-no" title="statement not covered" >n(5222),</span>c=<span class="cstat-no" title="statement not covered" >r(n(1227)),</span>u=<span class="cstat-no" title="statement not covered" >n(5260),</span>l=<span class="cstat-no" title="statement not covered" >n(1373),</span>h=<span class="cstat-no" title="statement not covered" >n(5552),</span>d=<span class="cstat-no" title="statement not covered" >(0,c.default)("engine.io-client:socket");</span>class f extends u.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super(),this.binaryType=h.defaultBinaryType,this.writeBuffer=[],e&amp;&amp;"object"==typeof e&amp;&amp;(t=e,e=null),e?(e=(0,a.parse)(e),t.hostname=e.host,t.secure="https"===e.protocol||"wss"===e.protocol,t.port=e.port,e.query&amp;&amp;(t.query=e.query)):t.host&amp;&amp;(t.hostname=(0,a.parse)(t.host).host),(0,o.installTimerFunctions)(this,t),this.secure=null!=t.secure?t.secure:"undefined"!=typeof location&amp;&amp;"https:"===location.protocol,t.hostname&amp;&amp;!t.port&amp;&amp;(t.port=this.secure?"443":"80"),this.hostname=t.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=t.port||("undefined"!=typeof location&amp;&amp;location.port?location.port:this.secure?"443":"80"),this.transports=t.transports||["polling","websocket","webtransport"],this.writeBuffer=[],this.prevBufferLen=0,this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!1},t),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),"string"==typeof this.opts.query&amp;&amp;(this.opts.query=(0,i.decode)(this.opts.query)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingTimeoutTimer=null,"function"==typeof addEventListener&amp;&amp;(this.opts.closeOnBeforeunload&amp;&amp;(this.beforeunloadEventListener=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.transport&amp;&amp;(this.transport.removeAllListeners(),this.transport.close())}</span>,addEventListener("beforeunload",this.beforeunloadEventListener,!1)),"localhost"!==this.hostname&amp;&amp;(this.offlineEventListener=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.onClose("transport close",{description:"network connection lost"})}</span>,addEventListener("offline",this.offlineEventListener,!1))),this.open()}<span class="fstat-no" title="function not covered" ></span>cr</span>eateTransport(e){<span class="cstat-no" title="statement not covered" >d('creating transport "%s"',e);c</span>onst t=<span class="cstat-no" title="statement not covered" >Object.assign({},this.opts.query);<span class="cstat-no" title="statement not covered" ></span>t.EIO=l.protocol,t.transport=e,this.id&amp;&amp;(t.sid=this.id);c</span>onst n=<span class="cstat-no" title="statement not covered" >Object.assign({},this.opts,{query:t,socket:this,hostname:this.hostname,secure:this.secure,port:this.port},this.opts.transportOptions[e]);<span class="cstat-no" title="statement not covered" ></span>return d("options: %j",n),new s.transports[e](n)}<span class="fstat-no" title="function not covered" ></span>op</span>en(){let e;<span class="cstat-no" title="statement not covered" >if(this.opts.rememberUpgrade&amp;&amp;f.priorWebsocketSuccess&amp;&amp;-1!==this.transports.indexOf("websocket"))<span class="cstat-no" title="statement not covered" >e="websocket";e</span>lse{<span class="cstat-no" title="statement not covered" >if(0===this.transports.length)<span class="cstat-no" title="statement not covered" >return void this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.emitReserved("error","No transports available")}</span>),0);<span class="cstat-no" title="statement not covered" >e</span></span>=this.transports[0]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.readyState="opening";<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >e=this.createTransport(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return d("error while creating transport: %s",e),this.transports.shift(),void this.open()}<span class="cstat-no" title="statement not covered" ></span>e</span>.open(),this.setTransport(e)}<span class="fstat-no" title="function not covered" ></span>se</span>tTransport(e){<span class="cstat-no" title="statement not covered" >d("setting transport %s",e.name),this.transport&amp;&amp;(d("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=e,e.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onClose("transport close",e))</span>)}<span class="fstat-no" title="function not covered" ></span>pr</span>obe(e){<span class="cstat-no" title="statement not covered" >d('probing transport "%s"',e);l</span>et t=<span class="cstat-no" title="statement not covered" >this.createTransport(e),</span>n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>f.priorWebsocketSuccess=!1;c</span>onst r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n||(d('probe transport "%s" opened',e),t.send([{type:"ping",data:"probe"}]),t.once("packet",(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!n)<span class="cstat-no" title="statement not covered" >if("pong"===r.type&amp;&amp;"probe"===r.data){<span class="cstat-no" title="statement not covered" >if(d('probe transport "%s" pong',e),this.upgrading=!0,this.emitReserved("upgrading",t),!t)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span></span>.priorWebsocketSuccess="websocket"===t.name,d('pausing current transport "%s"',this.transport.name),this.transport.pause((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n||"closed"!==this.readyState&amp;&amp;(d("changing transport and sending upgrade packet"),u(),this.setTransport(t),t.send([{type:"upgrade"}]),this.emitReserved("upgrade",t),t=null,this.upgrading=!1,this.flush())}</span>))}</span>else{<span class="cstat-no" title="statement not covered" >d('probe transport "%s" failed',e);c</span>onst n=<span class="cstat-no" title="statement not covered" >new Error("probe error");<span class="cstat-no" title="statement not covered" ></span>n.transport=t.name,this.emitReserved("upgradeError",n)}</span>}</span></span>)))}</span>;</span>function <span class="fstat-no" title="function not covered" >s(</span>){<span class="cstat-no" title="statement not covered" >n||(n=!0,u(),t.close(),t=null)}</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >new Error("probe error: "+n);<span class="cstat-no" title="statement not covered" ></span>r.transport=t.name,s(),d('probe transport "%s" failed because of error: %s',e,n),this.emitReserved("upgradeError",r)}</span>;</span>function <span class="fstat-no" title="function not covered" >i(</span>){<span class="cstat-no" title="statement not covered" >o("transport closed")}</span>function <span class="fstat-no" title="function not covered" >a(</span>){<span class="cstat-no" title="statement not covered" >o("socket closed")}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >t&amp;&amp;e.name!==t.name&amp;&amp;(d('"%s" works - aborting "%s"',e.name,t.name),s())}</span>const u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.removeListener("open",r),t.removeListener("error",o),t.removeListener("close",i),this.off("close",a),this.off("upgrading",c)}</span>;<span class="cstat-no" title="statement not covered" ></span>t.once("open",r),t.once("error",o),t.once("close",i),this.once("close",a),this.once("upgrading",c),-1!==this.upgrades.indexOf("webtransport")&amp;&amp;"webtransport"!==e?this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n||t.open()}</span>),200):t.open()}<span class="fstat-no" title="function not covered" ></span>on</span>Open(){<span class="cstat-no" title="statement not covered" >if(d("socket open"),this.readyState="open",f.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush(),"open"===this.readyState&amp;&amp;this.opts.upgrade){<span class="cstat-no" title="statement not covered" >d("starting upgrade probes");l</span>et e=<span class="cstat-no" title="statement not covered" >0;</span>const t=<span class="cstat-no" title="statement not covered" >this.upgrades.length;<span class="cstat-no" title="statement not covered" ></span>for(;e&lt;t;e++)<span class="cstat-no" title="statement not covered" >this.probe(this.upgrades[e])}</span></span>}<span class="fstat-no" title="function not covered" ></span>on</span>Packet(e){<span class="cstat-no" title="statement not covered" >if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)<span class="cstat-no" title="statement not covered" >switch(d('socket receive: type "%s", data "%s"',e.type,e.data),this.emitReserved("packet",e),this.emitReserved("heartbeat"),this.resetPingTimeout(),e.type){case"open":<span class="cstat-no" title="statement not covered" >this.onHandshake(JSON.parse(e.data));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ping":<span class="cstat-no" title="statement not covered" >this.sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":const t=<span class="cstat-no" title="statement not covered" >new Error("server error");<span class="cstat-no" title="statement not covered" ></span>t.code=e.data,this.onError(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"message":<span class="cstat-no" title="statement not covered" >this.emitReserved("data",e.data),this.emitReserved("message",e.data)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >d('packet received with socket readyState "%s"',this.readyState)}<span class="fstat-no" title="function not covered" ></span></span>on</span>Handshake(e){<span class="cstat-no" title="statement not covered" >this.emitReserved("handshake",e),this.id=e.sid,this.transport.query.sid=e.sid,this.upgrades=this.filterUpgrades(e.upgrades),this.pingInterval=e.pingInterval,this.pingTimeout=e.pingTimeout,this.maxPayload=e.maxPayload,this.onOpen(),"closed"!==this.readyState&amp;&amp;this.resetPingTimeout()}<span class="fstat-no" title="function not covered" ></span>re</span>setPingTimeout(){<span class="cstat-no" title="statement not covered" >this.clearTimeoutFn(this.pingTimeoutTimer),this.pingTimeoutTimer=this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.onClose("ping timeout")}</span>),this.pingInterval+this.pingTimeout),this.opts.autoUnref&amp;&amp;this.pingTimeoutTimer.unref()}<span class="fstat-no" title="function not covered" ></span>on</span>Drain(){<span class="cstat-no" title="statement not covered" >this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}<span class="fstat-no" title="function not covered" ></span>fl</span>ush(){<span class="cstat-no" title="statement not covered" >if("closed"!==this.readyState&amp;&amp;this.transport.writable&amp;&amp;!this.upgrading&amp;&amp;this.writeBuffer.length){const e=<span class="cstat-no" title="statement not covered" >this.getWritablePackets();<span class="cstat-no" title="statement not covered" ></span>d("flushing %d packets in socket",e.length),this.transport.send(e),this.prevBufferLen=e.length,this.emitReserved("flush")}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tWritablePackets(){<span class="cstat-no" title="statement not covered" >if(!(this.maxPayload&amp;&amp;"polling"===this.transport.name&amp;&amp;this.writeBuffer.length&gt;1))<span class="cstat-no" title="statement not covered" >return this.writeBuffer;l</span></span>et e=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;this.writeBuffer.length;t++){const n=<span class="cstat-no" title="statement not covered" >this.writeBuffer[t].data;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(e+=(0,o.byteLength)(n)),t&gt;0&amp;&amp;e&gt;this.maxPayload)<span class="cstat-no" title="statement not covered" >return d("only send %d out of %d packets",t,this.writeBuffer.length),this.writeBuffer.slice(0,t);<span class="cstat-no" title="statement not covered" >e</span></span>+=2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d("payload size is %d (max: %d)",e,this.maxPayload),this.writeBuffer}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(e,t,n){<span class="cstat-no" title="statement not covered" >return this.sendPacket("message",e,t,n),this}<span class="fstat-no" title="function not covered" ></span>se</span>nd(e,t,n){<span class="cstat-no" title="statement not covered" >return this.sendPacket("message",e,t,n),this}<span class="fstat-no" title="function not covered" ></span>se</span>ndPacket(e,t,n,r){<span class="cstat-no" title="statement not covered" >if("function"==typeof t&amp;&amp;(r=t,t=void 0),"function"==typeof n&amp;&amp;(r=n,n=null),"closing"===this.readyState||"closed"===this.readyState)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >(</span></span>n=n||{}).compress=!1!==n.compress;c</span>onst s=<span class="cstat-no" title="statement not covered" >{type:e,data:t,options:n};<span class="cstat-no" title="statement not covered" ></span>this.emitReserved("packetCreate",s),this.writeBuffer.push(s),r&amp;&amp;this.once("flush",r),this.flush()}<span class="fstat-no" title="function not covered" ></span>cl</span>ose(){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.onClose("forced close"),d("socket closing - telling transport to close"),this.transport.close()}</span>,</span>t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.off("upgrade",t),this.off("upgradeError",t),e()}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.once("upgrade",t),this.once("upgradeError",t)}</span>;<span class="cstat-no" title="statement not covered" ></span>return"opening"!==this.readyState&amp;&amp;"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.upgrading?n():e()}</span>)):this.upgrading?n():e()),this}<span class="fstat-no" title="function not covered" ></span>on</span>Error(e){<span class="cstat-no" title="statement not covered" >d("socket error %j",e),f.priorWebsocketSuccess=!1,this.emitReserved("error",e),this.onClose("transport error",e)}<span class="fstat-no" title="function not covered" ></span>on</span>Close(e,t){<span class="cstat-no" title="statement not covered" >"opening"!==this.readyState&amp;&amp;"open"!==this.readyState&amp;&amp;"closing"!==this.readyState||(d('socket close with reason: "%s"',e),this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),"function"==typeof removeEventListener&amp;&amp;(removeEventListener("beforeunload",this.beforeunloadEventListener,!1),removeEventListener("offline",this.offlineEventListener,!1)),this.readyState="closed",this.id=null,this.emitReserved("close",e,t),this.writeBuffer=[],this.prevBufferLen=0)}<span class="fstat-no" title="function not covered" ></span>fi</span>lterUpgrades(e){const t=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >0;</span>const r=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;r;n++)<span class="cstat-no" title="statement not covered" >~this.transports.indexOf(e[n])&amp;&amp;t.push(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>}<span class="cstat-no" title="statement not covered" >t.Socket=f,f.protocol=l.protocol}</span>,9870:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Transport=t.TransportError=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(1373),</span>o=<span class="cstat-no" title="statement not covered" >n(5260),</span>i=<span class="cstat-no" title="statement not covered" >n(9622),</span>a=<span class="cstat-no" title="statement not covered" >r(n(1227)),</span>c=<span class="cstat-no" title="statement not covered" >n(5754),</span>u=<span class="cstat-no" title="statement not covered" >(0,a.default)("engine.io-client:transport");</span>class l extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >super(e),this.description=t,this.context=n,this.type="TransportError"}</span>}<span class="cstat-no" title="statement not covered" >t.TransportError=l;c</span>lass h extends o.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(),this.writable=!1,(0,i.installTimerFunctions)(this,e),this.opts=e,this.query=e.query,this.socket=e.socket}<span class="fstat-no" title="function not covered" ></span>on</span>Error(e,t,n){<span class="cstat-no" title="statement not covered" >return super.emitReserved("error",new l(e,t,n)),this}<span class="fstat-no" title="function not covered" ></span>op</span>en(){<span class="cstat-no" title="statement not covered" >return this.readyState="opening",this.doOpen(),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ose(){<span class="cstat-no" title="statement not covered" >return"opening"!==this.readyState&amp;&amp;"open"!==this.readyState||(this.doClose(),this.onClose()),this}<span class="fstat-no" title="function not covered" ></span>se</span>nd(e){<span class="cstat-no" title="statement not covered" >"open"===this.readyState?this.write(e):u("transport is not open, discarding packets")}<span class="fstat-no" title="function not covered" ></span>on</span>Open(){<span class="cstat-no" title="statement not covered" >this.readyState="open",this.writable=!0,super.emitReserved("open")}<span class="fstat-no" title="function not covered" ></span>on</span>Data(e){const t=<span class="cstat-no" title="statement not covered" >(0,s.decodePacket)(e,this.socket.binaryType);<span class="cstat-no" title="statement not covered" ></span>this.onPacket(t)}<span class="fstat-no" title="function not covered" ></span>on</span>Packet(e){<span class="cstat-no" title="statement not covered" >super.emitReserved("packet",e)}<span class="fstat-no" title="function not covered" ></span>on</span>Close(e){<span class="cstat-no" title="statement not covered" >this.readyState="closed",super.emitReserved("close",e)}<span class="fstat-no" title="function not covered" ></span>pa</span>use(e){}<span class="fstat-no" title="function not covered" >cr</span>eateUri(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return e+"://"+this._hostname()+this._port()+this.opts.path+this._query(t)}<span class="fstat-no" title="function not covered" ></span>_h</span>ostname(){const e=<span class="cstat-no" title="statement not covered" >this.opts.hostname;<span class="cstat-no" title="statement not covered" ></span>return-1===e.indexOf(":")?e:"["+e+"]"}<span class="fstat-no" title="function not covered" ></span>_p</span>ort(){<span class="cstat-no" title="statement not covered" >return this.opts.port&amp;&amp;(this.opts.secure&amp;&amp;Number(443!==this.opts.port)||!this.opts.secure&amp;&amp;80!==Number(this.opts.port))?":"+this.opts.port:""}<span class="fstat-no" title="function not covered" ></span>_q</span>uery(e){const t=<span class="cstat-no" title="statement not covered" >(0,c.encode)(e);<span class="cstat-no" title="statement not covered" ></span>return t.length?"?"+t:""}</span>}<span class="cstat-no" title="statement not covered" >t.Transport=h}</span>,7385:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.transports=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(484),</span>s=<span class="cstat-no" title="statement not covered" >n(1308),</span>o=<span class="cstat-no" title="statement not covered" >n(1020);<span class="cstat-no" title="statement not covered" ></span>t.transports={websocket:s.WS,webtransport:o.WT,polling:r.Polling}}</span>,484:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Request=t.Polling=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(9870),</span>o=<span class="cstat-no" title="statement not covered" >r(n(1227)),</span>i=<span class="cstat-no" title="statement not covered" >n(8726),</span>a=<span class="cstat-no" title="statement not covered" >n(1373),</span>c=<span class="cstat-no" title="statement not covered" >n(6666),</span>u=<span class="cstat-no" title="statement not covered" >n(5260),</span>l=<span class="cstat-no" title="statement not covered" >n(9622),</span>h=<span class="cstat-no" title="statement not covered" >n(6242),</span>d=<span class="cstat-no" title="statement not covered" >(0,o.default)("engine.io-client:polling");</span>function <span class="fstat-no" title="function not covered" >f(</span>){}const p=<span class="cstat-no" title="statement not covered" >null!=new c.XHR({xdomain:!1}).responseType;</span>class y extends s.Transport{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >if(super(e),this.polling=!1,"undefined"!=typeof location){const t=<span class="cstat-no" title="statement not covered" >"https:"===location.protocol;</span>let n=<span class="cstat-no" title="statement not covered" >location.port;<span class="cstat-no" title="statement not covered" ></span>n||(n=t?"443":"80"),this.xd="undefined"!=typeof location&amp;&amp;e.hostname!==location.hostname||n!==e.port}</span>c</span>onst t=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.forceBase64;<span class="cstat-no" title="statement not covered" ></span>this.supportsBinary=p&amp;&amp;!t,this.opts.withCredentials&amp;&amp;(this.cookieJar=(0,c.createCookieJar)())}<span class="fstat-no" title="function not covered" ></span>ge</span>t name(){<span class="cstat-no" title="statement not covered" >return"polling"}<span class="fstat-no" title="function not covered" ></span>do</span>Open(){<span class="cstat-no" title="statement not covered" >this.poll()}<span class="fstat-no" title="function not covered" ></span>pa</span>use(e){<span class="cstat-no" title="statement not covered" >this.readyState="pausing";c</span>onst t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >d("paused"),this.readyState="paused",e()}</span>;<span class="cstat-no" title="statement not covered" ></span>if(this.polling||!this.writable){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.polling&amp;&amp;(d("we are currently polling - waiting to pause"),e++,this.once("pollComplete",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >d("pre-pause polling complete"),--e||t()}</span>))),this.writable||(d("we are currently writing - waiting to pause"),e++,this.once("drain",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >d("pre-pause writing complete"),--e||t()}</span>)))}</span>else <span class="cstat-no" title="statement not covered" >t()}<span class="fstat-no" title="function not covered" ></span></span>po</span>ll(){<span class="cstat-no" title="statement not covered" >d("polling"),this.polling=!0,this.doPoll(),this.emitReserved("poll")}<span class="fstat-no" title="function not covered" ></span>on</span>Data(e){<span class="cstat-no" title="statement not covered" >d("polling got data %s",e),(0,a.decodePayload)(e,this.socket.binaryType).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if("opening"===this.readyState&amp;&amp;"open"===e.type&amp;&amp;this.onOpen(),"close"===e.type)<span class="cstat-no" title="statement not covered" >return this.onClose({description:"transport closed by the server"}),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.onPacket(e)}</span>)),"closed"!==this.readyState&amp;&amp;(this.polling=!1,this.emitReserved("pollComplete"),"open"===this.readyState?this.poll():d('ignoring poll - transport state "%s"',this.readyState))}<span class="fstat-no" title="function not covered" ></span>do</span>Close(){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >d("writing close packet"),this.write([{type:"close"}])}</span>;<span class="cstat-no" title="statement not covered" ></span>"open"===this.readyState?(d("transport open - closing"),e()):(d("transport not open - deferring close"),this.once("open",e))}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(e){<span class="cstat-no" title="statement not covered" >this.writable=!1,(0,a.encodePayload)(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.doWrite(e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.writable=!0,this.emitReserved("drain")}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>ur</span>i(){const e=<span class="cstat-no" title="statement not covered" >this.opts.secure?"https":"http",</span>t=<span class="cstat-no" title="statement not covered" >this.query||{};<span class="cstat-no" title="statement not covered" ></span>return!1!==this.opts.timestampRequests&amp;&amp;(t[this.opts.timestampParam]=(0,i.yeast)()),this.supportsBinary||t.sid||(t.b64=1),this.createUri(e,t)}<span class="fstat-no" title="function not covered" ></span>re</span>quest(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return Object.assign(e,{xd:this.xd,cookieJar:this.cookieJar},this.opts),new g(this.uri(),e)}<span class="fstat-no" title="function not covered" ></span>do</span>Write(e,t){const n=<span class="cstat-no" title="statement not covered" >this.request({method:"POST",data:e});<span class="cstat-no" title="statement not covered" ></span>n.on("success",t),n.on("error",(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >this.onError("xhr post error",e,t)}</span>))}<span class="fstat-no" title="function not covered" ></span>do</span>Poll(){<span class="cstat-no" title="statement not covered" >d("xhr poll");c</span>onst e=<span class="cstat-no" title="statement not covered" >this.request();<span class="cstat-no" title="statement not covered" ></span>e.on("data",this.onData.bind(this)),e.on("error",(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >this.onError("xhr poll error",e,t)}</span>)),this.pollXhr=e}</span>}<span class="cstat-no" title="statement not covered" >t.Polling=y;c</span>lass g extends u.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(),(0,l.installTimerFunctions)(this,t),this.opts=t,this.method=t.method||"GET",this.uri=e,this.data=void 0!==t.data?t.data:null,this.create()}<span class="fstat-no" title="function not covered" ></span>cr</span>eate(){var e;const t=<span class="cstat-no" title="statement not covered" >(0,l.pick)(this.opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");<span class="cstat-no" title="statement not covered" ></span>t.xdomain=!!this.opts.xd;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.xhr=new c.XHR(t);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >d("xhr open %s: %s",this.method,this.uri),n.open(this.method,this.uri,!0);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >if(this.opts.extraHeaders){<span class="cstat-no" title="statement not covered" >n.setDisableHeaderCheck&amp;&amp;n.setDisableHeaderCheck(!0);<span class="cstat-no" title="statement not covered" >f</span>or(let e in this.opts.extraHeaders)<span class="cstat-no" title="statement not covered" >this.opts.extraHeaders.hasOwnProperty(e)&amp;&amp;n.setRequestHeader(e,this.opts.extraHeaders[e])}</span></span>}</span>catch(e){}<span class="cstat-no" title="statement not covered" >i</span>f("POST"===this.method)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}</span>catch(e){}<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >n.setRequestHeader("Accept","*/*")}</span>catch(e){}<span class="cstat-no" title="statement not covered" >n</span>ull===(e=this.opts.cookieJar)||void 0===e||e.addCookies(n),"withCredentials"in n&amp;&amp;(n.withCredentials=this.opts.withCredentials),this.opts.requestTimeout&amp;&amp;(n.timeout=this.opts.requestTimeout),n.onreadystatechange=<span class="fstat-no" title="function not covered" >()</span>=&gt;{var e;<span class="cstat-no" title="statement not covered" >3===n.readyState&amp;&amp;(null===(e=this.opts.cookieJar)||void 0===e||e.parseCookies(n)),4===n.readyState&amp;&amp;(200===n.status||1223===n.status?this.onLoad():this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.onError("number"==typeof n.status?n.status:0)}</span>),0))}</span>,d("xhr data %s",this.data),n.send(this.data)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.onError(e)}</span>),0)}<span class="cstat-no" title="statement not covered" ></span>"</span>undefined"!=typeof document&amp;&amp;(this.index=g.requestsCount++,g.requests[this.index]=this)}<span class="fstat-no" title="function not covered" ></span>on</span>Error(e){<span class="cstat-no" title="statement not covered" >this.emitReserved("error",e,this.xhr),this.cleanup(!0)}<span class="fstat-no" title="function not covered" ></span>cl</span>eanup(e){<span class="cstat-no" title="statement not covered" >if(void 0!==this.xhr&amp;&amp;null!==this.xhr){<span class="cstat-no" title="statement not covered" >if(this.xhr.onreadystatechange=f,e)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.xhr.abort()}</span>catch(e){}<span class="cstat-no" title="statement not covered" >"</span></span>undefined"!=typeof document&amp;&amp;delete g.requests[this.index],this.xhr=null}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>Load(){const e=<span class="cstat-no" title="statement not covered" >this.xhr.responseText;<span class="cstat-no" title="statement not covered" ></span>null!==e&amp;&amp;(this.emitReserved("data",e),this.emitReserved("success"),this.cleanup())}<span class="fstat-no" title="function not covered" ></span>ab</span>ort(){<span class="cstat-no" title="statement not covered" >this.cleanup()}</span>}<span class="cstat-no" title="statement not covered" >if(t.Request=g,g.requestsCount=0,g.requests={},"undefined"!=typeof document)<span class="cstat-no" title="statement not covered" >if("function"==typeof attachEvent)<span class="cstat-no" title="statement not covered" >attachEvent("onunload",v);e</span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof addEventListener){const e=<span class="cstat-no" title="statement not covered" >"onpagehide"in h.globalThisShim?"pagehide":"unload";<span class="cstat-no" title="statement not covered" ></span>addEventListener(e,v,!1)}</span>f</span></span></span>unction <span class="fstat-no" title="function not covered" >v(</span>){<span class="cstat-no" title="statement not covered" >for(let e in g.requests)<span class="cstat-no" title="statement not covered" >g.requests.hasOwnProperty(e)&amp;&amp;g.requests[e].abort()}</span></span>},5552:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.defaultBinaryType=t.usingBrowserWebSocket=t.WebSocket=t.nextTick=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(6242);<span class="cstat-no" title="statement not covered" ></span>t.nextTick="function"==typeof Promise&amp;&amp;"function"==typeof Promise.resolve?<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve().then(e):<span class="fstat-no" title="function not covered" ></span>(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >t(e,0),</span>t.WebSocket=r.globalThisShim.WebSocket||r.globalThisShim.MozWebSocket,t.usingBrowserWebSocket=!0,t.defaultBinaryType="arraybuffer"}</span>,1308:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.WS=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(9870),</span>o=<span class="cstat-no" title="statement not covered" >n(8726),</span>i=<span class="cstat-no" title="statement not covered" >n(9622),</span>a=<span class="cstat-no" title="statement not covered" >n(5552),</span>c=<span class="cstat-no" title="statement not covered" >r(n(1227)),</span>u=<span class="cstat-no" title="statement not covered" >n(1373),</span>l=<span class="cstat-no" title="statement not covered" >(0,c.default)("engine.io-client:websocket"),</span>h=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;"string"==typeof navigator.product&amp;&amp;"reactnative"===navigator.product.toLowerCase();</span>class d extends s.Transport{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(e),this.supportsBinary=!e.forceBase64}<span class="fstat-no" title="function not covered" ></span>ge</span>t name(){<span class="cstat-no" title="statement not covered" >return"websocket"}<span class="fstat-no" title="function not covered" ></span>do</span>Open(){<span class="cstat-no" title="statement not covered" >if(!this.check())<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.uri(),</span>t=<span class="cstat-no" title="statement not covered" >this.opts.protocols,</span>n=<span class="cstat-no" title="statement not covered" >h?{}:(0,i.pick)(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");<span class="cstat-no" title="statement not covered" ></span>this.opts.extraHeaders&amp;&amp;(n.headers=this.opts.extraHeaders);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.ws=a.usingBrowserWebSocket&amp;&amp;!h?t?new a.WebSocket(e,t):new a.WebSocket(e):new a.WebSocket(e,t,n)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return this.emitReserved("error",e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ws.binaryType=this.socket.binaryType,this.addEventListeners()}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListeners(){<span class="cstat-no" title="statement not covered" >this.ws.onopen=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.opts.autoUnref&amp;&amp;this.ws._socket.unref(),this.onOpen()}</span>,this.ws.onclose=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onClose({description:"websocket connection closed",context:e}),</span>this.ws.onmessage=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onData(e.data),</span>this.ws.onerror=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onError("websocket error",e)}<span class="fstat-no" title="function not covered" ></span></span>wr</span>ite(e){<span class="cstat-no" title="statement not covered" >this.writable=!1;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t++){const n=<span class="cstat-no" title="statement not covered" >e[t],</span>r=<span class="cstat-no" title="statement not covered" >t===e.length-1;<span class="cstat-no" title="statement not covered" ></span>(0,u.encodePacket)(n,this.supportsBinary,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>!a.usingBrowserWebSocket&amp;&amp;(n.options&amp;&amp;(t.compress=n.options.compress),this.opts.perMessageDeflate)&amp;&amp;("string"==typeof e?Buffer.byteLength(e):e.length)&lt;this.opts.perMessageDeflate.threshold&amp;&amp;(t.compress=!1);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >a.usingBrowserWebSocket?this.ws.send(e):this.ws.send(e,t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >l("websocket closed before onclose event")}<span class="cstat-no" title="statement not covered" ></span>r</span>&amp;&amp;(0,a.nextTick)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.writable=!0,this.emitReserved("drain")}</span>),this.setTimeoutFn)}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>do</span>Close(){<span class="cstat-no" title="statement not covered" >void 0!==this.ws&amp;&amp;(this.ws.close(),this.ws=null)}<span class="fstat-no" title="function not covered" ></span>ur</span>i(){const e=<span class="cstat-no" title="statement not covered" >this.opts.secure?"wss":"ws",</span>t=<span class="cstat-no" title="statement not covered" >this.query||{};<span class="cstat-no" title="statement not covered" ></span>return this.opts.timestampRequests&amp;&amp;(t[this.opts.timestampParam]=(0,o.yeast)()),this.supportsBinary||(t.b64=1),this.createUri(e,t)}<span class="fstat-no" title="function not covered" ></span>ch</span>eck(){<span class="cstat-no" title="statement not covered" >return!!a.WebSocket}</span>}<span class="cstat-no" title="statement not covered" >t.WS=d}</span>,1020:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.WT=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(9870),</span>o=<span class="cstat-no" title="statement not covered" >n(5552),</span>i=<span class="cstat-no" title="statement not covered" >n(1373),</span>a=<span class="cstat-no" title="statement not covered" >(0,r(n(1227)).default)("engine.io-client:webtransport");</span>class c extends s.Transport{<span class="fstat-no" title="function not covered" >ge</span>t name(){<span class="cstat-no" title="statement not covered" >return"webtransport"}<span class="fstat-no" title="function not covered" ></span>do</span>Open(){<span class="cstat-no" title="statement not covered" >"function"==typeof WebTransport&amp;&amp;(this.transport=new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name]),this.transport.closed.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a("transport closed gracefully"),this.onClose()}</span>)).catch((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >a("transport closed due to %s",e),this.onError("webtransport error",e)}</span>)),this.transport.ready.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.transport.createBidirectionalStream().then((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >(0,i.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER,this.socket.binaryType),</span>n=<span class="cstat-no" title="statement not covered" >e.readable.pipeThrough(t).getReader(),</span>r=<span class="cstat-no" title="statement not covered" >(0,i.createPacketEncoderStream)();<span class="cstat-no" title="statement not covered" ></span>r.readable.pipeTo(e.writable),this.writer=r.writable.getWriter();c</span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.read().then((<span class="fstat-no" title="function not covered" >({</span>done:e,value:t})=&gt;{<span class="cstat-no" title="statement not covered" >e?a("session is closed"):(a("received chunk: %o",t),this.onPacket(t),s())}</span>)).catch((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >a("an error occurred while reading: %s",e)}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>s();c</span>onst o=<span class="cstat-no" title="statement not covered" >{type:"open"};<span class="cstat-no" title="statement not covered" ></span>this.query.sid&amp;&amp;(o.data=`{"sid":"${this.query.sid}"}`),this.writer.write(o).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onOpen())</span>)}</span>))}</span>)))}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(e){<span class="cstat-no" title="statement not covered" >this.writable=!1;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t++){const n=<span class="cstat-no" title="statement not covered" >e[t],</span>r=<span class="cstat-no" title="statement not covered" >t===e.length-1;<span class="cstat-no" title="statement not covered" ></span>this.writer.write(n).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r&amp;&amp;(0,o.nextTick)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.writable=!0,this.emitReserved("drain")}</span>),this.setTimeoutFn)}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>do</span>Close(){var e;<span class="cstat-no" title="statement not covered" >null===(e=this.transport)||void 0===e||e.close()}</span>}<span class="cstat-no" title="statement not covered" >t.WT=c}</span>,6666:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.createCookieJar=t.XHR=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(8419),</span>s=<span class="cstat-no" title="statement not covered" >n(6242);<span class="cstat-no" title="statement not covered" ></span>t.XHR=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e.xdomain;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof XMLHttpRequest&amp;&amp;(!t||r.hasCORS))<span class="cstat-no" title="statement not covered" >return new XMLHttpRequest}</span></span>catch(e){}<span class="cstat-no" title="statement not covered" >i</span>f(!t)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return new(s.globalThisShim[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}</span>catch(e){}}</span></span>,t.createCookieJar=<span class="fstat-no" title="function not covered" >fu</span>nction(){}}</span>,9622:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.byteLength=t.installTimerFunctions=t.pick=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(6242);<span class="cstat-no" title="statement not covered" ></span>t.pick=<span class="fstat-no" title="function not covered" >fu</span>nction(e,...t){<span class="cstat-no" title="statement not covered" >return t.reduce((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;(<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(n)&amp;&amp;(t[n]=e[n]),t)</span>),{})}</span>;c</span>onst s=<span class="cstat-no" title="statement not covered" >r.globalThisShim.setTimeout,</span>o=<span class="cstat-no" title="statement not covered" >r.globalThisShim.clearTimeout;<span class="cstat-no" title="statement not covered" ></span>t.installTimerFunctions=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >t.useNativeTimers?(e.setTimeoutFn=s.bind(r.globalThisShim),e.clearTimeoutFn=o.bind(r.globalThisShim)):(e.setTimeoutFn=r.globalThisShim.setTimeout.bind(r.globalThisShim),e.clearTimeoutFn=r.globalThisShim.clearTimeout.bind(r.globalThisShim))}</span>,t.byteLength=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.length;</span>r&lt;s;r++)<span class="cstat-no" title="statement not covered" >t=e.charCodeAt(r),t&lt;128?n+=1:t&lt;2048?n+=2:t&lt;55296||t&gt;=57344?n+=3:(r++,n+=4);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>(e):Math.ceil(1.33*(e.byteLength||e.size))}</span>}</span>,3087:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.ERROR_PACKET=t.PACKET_TYPES_REVERSE=t.PACKET_TYPES=void 0;c</span>onst n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>t.PACKET_TYPES=n,n.open="0",n.close="1",n.ping="2",n.pong="3",n.message="4",n.upgrade="5",n.noop="6";c</span>onst r=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>t.PACKET_TYPES_REVERSE=r,Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r[n[e]]=e}</span>)),t.ERROR_PACKET={type:"error",data:"parser error"}}</span>,2469:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=void 0;c</span>onst n=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",</span>r=<span class="cstat-no" title="statement not covered" >"undefined"==typeof Uint8Array?[]:new Uint8Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;64;e++)<span class="cstat-no" title="statement not covered" >r[n.charCodeAt(e)]=e;<span class="cstat-no" title="statement not covered" >t</span></span>.encode=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t,r=<span class="cstat-no" title="statement not covered" >new Uint8Array(e),</span>s=<span class="cstat-no" title="statement not covered" >r.length,</span>o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;s;t+=3)<span class="cstat-no" title="statement not covered" >o+=n[r[t]&gt;&gt;2],o+=n[(3&amp;r[t])&lt;&lt;4|r[t+1]&gt;&gt;4],o+=n[(15&amp;r[t+1])&lt;&lt;2|r[t+2]&gt;&gt;6],o+=n[63&amp;r[t+2]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s%3==2?o=o.substring(0,o.length-1)+"=":s%3==1&amp;&amp;(o=o.substring(0,o.length-2)+"=="),o}</span>,t.decode=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t,n,s,o,i,a=<span class="cstat-no" title="statement not covered" >.75*e.length,</span>c=<span class="cstat-no" title="statement not covered" >e.length,</span>u=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>"="===e[e.length-1]&amp;&amp;(a--,"="===e[e.length-2]&amp;&amp;a--);c</span>onst l=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(a),</span>h=<span class="cstat-no" title="statement not covered" >new Uint8Array(l);<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;c;t+=4)<span class="cstat-no" title="statement not covered" >n=r[e.charCodeAt(t)],s=r[e.charCodeAt(t+1)],o=r[e.charCodeAt(t+2)],i=r[e.charCodeAt(t+3)],h[u++]=n&lt;&lt;2|s&gt;&gt;4,h[u++]=(15&amp;s)&lt;&lt;4|o&gt;&gt;2,h[u++]=(3&amp;o)&lt;&lt;6|63&amp;i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>}</span>,7572:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.decodePacket=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(3087),</span>s=<span class="cstat-no" title="statement not covered" >n(2469),</span>o=<span class="cstat-no" title="statement not covered" >"function"==typeof ArrayBuffer;<span class="cstat-no" title="statement not covered" ></span>t.decodePacket=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >return{type:"message",data:a(e,t)};c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e.charAt(0);<span class="cstat-no" title="statement not covered" ></span>return"b"===n?{type:"message",data:i(e.substring(1),t)}:r.PACKET_TYPES_REVERSE[n]?e.length&gt;1?{type:r.PACKET_TYPES_REVERSE[n],data:e.substring(1)}:{type:r.PACKET_TYPES_REVERSE[n]}:r.ERROR_PACKET}</span>;c</span>onst i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(o){const n=<span class="cstat-no" title="statement not covered" >(0,s.decode)(e);<span class="cstat-no" title="statement not covered" ></span>return a(n,t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{base64:!0,data:e}}</span>,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >"blob"===t?e instanceof Blob?e:new Blob([e]):e instanceof ArrayBuffer?e:e.buffer}</span></span>,3908:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.encodePacket=t.encodePacketToBinary=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(3087),</span>s=<span class="cstat-no" title="statement not covered" >"function"==typeof Blob||"undefined"!=typeof Blob&amp;&amp;"[object BlobConstructor]"===Object.prototype.toString.call(Blob),</span>o=<span class="cstat-no" title="statement not covered" >"function"==typeof ArrayBuffer,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):e&amp;&amp;e.buffer instanceof ArrayBuffer,</span></span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>type:e,data:t},n,a)=&gt;<span class="cstat-no" title="statement not covered" >s&amp;&amp;t instanceof Blob?n?a(t):c(t,a):o&amp;&amp;(t instanceof ArrayBuffer||i(t))?n?a(t):c(new Blob([t]),a):a(r.PACKET_TYPES[e]+(t||""));<span class="cstat-no" title="statement not covered" ></span></span>t.encodePacket=a;c</span>onst c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >new FileReader;<span class="cstat-no" title="statement not covered" ></span>return n.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >n.result.split(",")[1];<span class="cstat-no" title="statement not covered" ></span>t("b"+(e||""))}</span>,n.readAsDataURL(e)}</span>;</span>function <span class="fstat-no" title="function not covered" >u(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}</span>let l;<span class="cstat-no" title="statement not covered" >t.encodePacketToBinary=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return s&amp;&amp;e.data instanceof Blob?e.data.arrayBuffer().then(u).then(t):o&amp;&amp;(e.data instanceof ArrayBuffer||i(e.data))?t(u(e.data)):void a(e,!1,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >l||(l=new TextEncoder),t(l.encode(e))}</span>))}</span>}</span>,1373:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.decodePayload=t.decodePacket=t.encodePayload=t.encodePacket=t.protocol=t.createPacketDecoderStream=t.createPacketEncoderStream=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(3908);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"encodePacket",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r.encodePacket}</span>});c</span>onst s=<span class="cstat-no" title="statement not covered" >n(7572);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"decodePacket",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.decodePacket}</span>});c</span>onst o=<span class="cstat-no" title="statement not covered" >n(3087),</span>i=<span class="cstat-no" title="statement not covered" >String.fromCharCode(30);</span>let a;function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >return e.reduce((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e+t.length)</span>,0)}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e[0].length===t)<span class="cstat-no" title="statement not covered" >return e.shift();c</span></span>onst n=<span class="cstat-no" title="statement not covered" >new Uint8Array(t);</span>let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t;s++)<span class="cstat-no" title="statement not covered" >n[s]=e[0][r++],r===e[0].length&amp;&amp;(e.shift(),r=0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.length&amp;&amp;r&lt;e[0].length&amp;&amp;(e[0]=e[0].slice(r)),n}<span class="cstat-no" title="statement not covered" ></span>t.encodePayload=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.length,</span>s=<span class="cstat-no" title="statement not covered" >new Array(n);</span>let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >(e</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >(0,r.encodePacket)(e,!1,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[a]=e,++o===n&amp;&amp;t(s.join(i))}</span>))}</span>))}</span>,t.decodePayload=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.split(i),</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;n.length;e++){const o=<span class="cstat-no" title="statement not covered" >(0,s.decodePacket)(n[e],t);<span class="cstat-no" title="statement not covered" ></span>if(r.push(o),"error"===o.type)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>,t.createPacketEncoderStream=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new TransformStream({<span class="fstat-no" title="function not covered" >tr</span>ansform(e,t){<span class="cstat-no" title="statement not covered" >(0,r.encodePacketToBinary)(e,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >n.length;</span>let s;<span class="cstat-no" title="statement not covered" >if(r&lt;126)<span class="cstat-no" title="statement not covered" >s=new Uint8Array(1),new DataView(s.buffer).setUint8(0,r);e</span>lse <span class="cstat-no" title="statement not covered" >if(r&lt;65536){<span class="cstat-no" title="statement not covered" >s=new Uint8Array(3);c</span>onst e=<span class="cstat-no" title="statement not covered" >new DataView(s.buffer);<span class="cstat-no" title="statement not covered" ></span>e.setUint8(0,126),e.setUint16(1,r)}</span>else{<span class="cstat-no" title="statement not covered" >s=new Uint8Array(9);c</span>onst e=<span class="cstat-no" title="statement not covered" >new DataView(s.buffer);<span class="cstat-no" title="statement not covered" ></span>e.setUint8(0,127),e.setBigUint64(1,BigInt(r))}<span class="cstat-no" title="statement not covered" ></span>e</span></span>.data&amp;&amp;"string"!=typeof e.data&amp;&amp;(s[0]|=128),t.enqueue(s),t.enqueue(n)}</span>))}</span>})}</span>,t.createPacketDecoderStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >a||(a=new TextDecoder);c</span>onst n=<span class="cstat-no" title="statement not covered" >[];</span>let r=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >-1,</span>l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return new TransformStream({<span class="fstat-no" title="function not covered" >tr</span>ansform(h,d){<span class="cstat-no" title="statement not covered" >for(n.push(h);;){<span class="cstat-no" title="statement not covered" >if(0===r){<span class="cstat-no" title="statement not covered" >if(c(n)&lt;1)<span class="cstat-no" title="statement not covered" >break;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >u(n,1);<span class="cstat-no" title="statement not covered" ></span>l=128==(128&amp;e[0]),i=127&amp;e[0],r=i&lt;126?3:126===i?1:2}</span>else <span class="cstat-no" title="statement not covered" >if(1===r){<span class="cstat-no" title="statement not covered" >if(c(n)&lt;2)<span class="cstat-no" title="statement not covered" >break;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >u(n,2);<span class="cstat-no" title="statement not covered" ></span>i=new DataView(e.buffer,e.byteOffset,e.length).getUint16(0),r=3}</span>else <span class="cstat-no" title="statement not covered" >if(2===r){<span class="cstat-no" title="statement not covered" >if(c(n)&lt;8)<span class="cstat-no" title="statement not covered" >break;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >u(n,8),</span>t=<span class="cstat-no" title="statement not covered" >new DataView(e.buffer,e.byteOffset,e.length),</span>s=<span class="cstat-no" title="statement not covered" >t.getUint32(0);<span class="cstat-no" title="statement not covered" ></span>if(s&gt;Math.pow(2,21)-1){<span class="cstat-no" title="statement not covered" >d.enqueue(o.ERROR_PACKET);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>=s*Math.pow(2,32)+t.getUint32(4),r=3}</span>else{<span class="cstat-no" title="statement not covered" >if(c(n)&lt;i)<span class="cstat-no" title="statement not covered" >break;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >u(n,i);<span class="cstat-no" title="statement not covered" ></span>d.enqueue((0,s.decodePacket)(l?e:a.decode(e),t)),r=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(0===i||i&gt;e){<span class="cstat-no" title="statement not covered" >d.enqueue(o.ERROR_PACKET);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>})}</span>,t.protocol=4}</span>,5159:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";function <span class="fstat-no" title="function not covered" >n(</span>e){<span class="cstat-no" title="statement not covered" >e=e||{},this.ms=e.min||100,this.max=e.max||1e4,this.factor=e.factor||2,this.jitter=e.jitter&gt;0&amp;&amp;e.jitter&lt;=1?e.jitter:0,this.attempts=0}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Backoff=void 0,t.Backoff=n,n.prototype.duration=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.ms*Math.pow(this.factor,this.attempts++);<span class="cstat-no" title="statement not covered" ></span>if(this.jitter){var t=<span class="cstat-no" title="statement not covered" >Math.random(),</span>n=<span class="cstat-no" title="statement not covered" >Math.floor(t*this.jitter*e);<span class="cstat-no" title="statement not covered" ></span>e=0==(1&amp;Math.floor(10*t))?e-n:e+n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0|Math.min(e,this.max)}</span>,n.prototype.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.attempts=0}</span>,n.prototype.setMin=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.ms=e}</span>,n.prototype.setMax=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.max=e}</span>,n.prototype.setJitter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.jitter=e}</span>}</span>,7046:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.connect=t.io=t.Socket=t.Manager=t.protocol=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(3084),</span>o=<span class="cstat-no" title="statement not covered" >n(4168);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"Manager",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.Manager}</span>});c</span>onst i=<span class="cstat-no" title="statement not covered" >n(8312);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"Socket",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.Socket}</span>});c</span>onst a=<span class="cstat-no" title="statement not covered" >r(n(1227)).default("socket.io-client"),</span>c=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t){<span class="cstat-no" title="statement not covered" >"object"==typeof e&amp;&amp;(t=e,e=void 0),t=t||{};c</span>onst n=<span class="cstat-no" title="statement not covered" >s.url(e,t.path||"/socket.io"),</span>r=<span class="cstat-no" title="statement not covered" >n.source,</span>i=<span class="cstat-no" title="statement not covered" >n.id,</span>u=<span class="cstat-no" title="statement not covered" >n.path,</span>l=<span class="cstat-no" title="statement not covered" >c[i]&amp;&amp;u in c[i].nsps;</span>let h;<span class="cstat-no" title="statement not covered" >return t.forceNew||t["force new connection"]||!1===t.multiplex||l?(a("ignoring socket cache for %s",r),h=new o.Manager(r,t)):(c[i]||(a("new io instance for %s",r),c[i]=new o.Manager(r,t)),h=c[i]),n.query&amp;&amp;!t.query&amp;&amp;(t.query=n.queryKey),h.socket(n.path,t)}<span class="cstat-no" title="statement not covered" ></span>t.io=u,t.connect=u,t.default=u,Object.assign(u,{Manager:o.Manager,Socket:i.Socket,io:u,connect:u});v</span>ar l=<span class="cstat-no" title="statement not covered" >n(4514);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"protocol",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.protocol}</span>}),e.exports=u}</span>,4168:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__createBinding||(Object.create?<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=n),Object.defineProperty(e,r,{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t[n]}</span>})}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=n),e[r]=t[n]}</span>),</span>s=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__setModuleDefault||(Object.create?<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"default",{enumerable:!0,value:t})}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.default=t}</span>),</span>o=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importStar||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;e.__esModule)<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var n in e)<span class="cstat-no" title="statement not covered" >"default"!==n&amp;&amp;Object.prototype.hasOwnProperty.call(e,n)&amp;&amp;r(t,e,n);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn s(t,e),t}</span>,</span>i=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Manager=void 0;c</span>onst a=<span class="cstat-no" title="statement not covered" >n(4679),</span>c=<span class="cstat-no" title="statement not covered" >n(8312),</span>u=<span class="cstat-no" title="statement not covered" >o(n(4514)),</span>l=<span class="cstat-no" title="statement not covered" >n(7149),</span>h=<span class="cstat-no" title="statement not covered" >n(5159),</span>d=<span class="cstat-no" title="statement not covered" >n(5260),</span>f=<span class="cstat-no" title="statement not covered" >i(n(1227)).default("socket.io-client:manager");</span>class p extends d.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){var n;<span class="cstat-no" title="statement not covered" >super(),this.nsps={},this.subs=[],e&amp;&amp;"object"==typeof e&amp;&amp;(t=e,e=void 0),(t=t||{}).path=t.path||"/socket.io",this.opts=t,a.installTimerFunctions(this,t),this.reconnection(!1!==t.reconnection),this.reconnectionAttempts(t.reconnectionAttempts||1/0),this.reconnectionDelay(t.reconnectionDelay||1e3),this.reconnectionDelayMax(t.reconnectionDelayMax||5e3),this.randomizationFactor(null!==(n=t.randomizationFactor)&amp;&amp;void 0!==n?n:.5),this.backoff=new h.Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==t.timeout?2e4:t.timeout),this._readyState="closed",this.uri=e;c</span>onst r=<span class="cstat-no" title="statement not covered" >t.parser||u;<span class="cstat-no" title="statement not covered" ></span>this.encoder=new r.Encoder,this.decoder=new r.Decoder,this._autoConnect=!1!==t.autoConnect,this._autoConnect&amp;&amp;this.open()}<span class="fstat-no" title="function not covered" ></span>re</span>connection(e){<span class="cstat-no" title="statement not covered" >return arguments.length?(this._reconnection=!!e,this):this._reconnection}<span class="fstat-no" title="function not covered" ></span>re</span>connectionAttempts(e){<span class="cstat-no" title="statement not covered" >return void 0===e?this._reconnectionAttempts:(this._reconnectionAttempts=e,this)}<span class="fstat-no" title="function not covered" ></span>re</span>connectionDelay(e){var t;<span class="cstat-no" title="statement not covered" >return void 0===e?this._reconnectionDelay:(this._reconnectionDelay=e,null===(t=this.backoff)||void 0===t||t.setMin(e),this)}<span class="fstat-no" title="function not covered" ></span>ra</span>ndomizationFactor(e){var t;<span class="cstat-no" title="statement not covered" >return void 0===e?this._randomizationFactor:(this._randomizationFactor=e,null===(t=this.backoff)||void 0===t||t.setJitter(e),this)}<span class="fstat-no" title="function not covered" ></span>re</span>connectionDelayMax(e){var t;<span class="cstat-no" title="statement not covered" >return void 0===e?this._reconnectionDelayMax:(this._reconnectionDelayMax=e,null===(t=this.backoff)||void 0===t||t.setMax(e),this)}<span class="fstat-no" title="function not covered" ></span>ti</span>meout(e){<span class="cstat-no" title="statement not covered" >return arguments.length?(this._timeout=e,this):this._timeout}<span class="fstat-no" title="function not covered" ></span>ma</span>ybeReconnectOnOpen(){<span class="cstat-no" title="statement not covered" >!this._reconnecting&amp;&amp;this._reconnection&amp;&amp;0===this.backoff.attempts&amp;&amp;this.reconnect()}<span class="fstat-no" title="function not covered" ></span>op</span>en(e){<span class="cstat-no" title="statement not covered" >if(f("readyState %s",this._readyState),~this._readyState.indexOf("open"))<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >f</span></span>("opening %s",this.uri),this.engine=new a.Socket(this.uri,this.opts);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.engine,</span>n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._readyState="opening",this.skipReconnect=!1;c</span>onst r=<span class="cstat-no" title="statement not covered" >l.on(t,"open",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.onopen(),e&amp;&amp;e()}</span>)),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >f("error"),this.cleanup(),this._readyState="closed",this.emitReserved("error",t),e?e(t):this.maybeReconnectOnOpen()}</span>,</span>o=<span class="cstat-no" title="statement not covered" >l.on(t,"error",s);<span class="cstat-no" title="statement not covered" ></span>if(!1!==this._timeout){const e=<span class="cstat-no" title="statement not covered" >this._timeout;<span class="cstat-no" title="statement not covered" ></span>f("connect attempt will timeout after %d",e);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >f("connect attempt timed out after %d",e),r(),s(new Error("timeout")),t.close()}</span>),e);<span class="cstat-no" title="statement not covered" ></span>this.opts.autoUnref&amp;&amp;n.unref(),this.subs.push((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.clearTimeoutFn(n)}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.subs.push(r),this.subs.push(o),this}<span class="fstat-no" title="function not covered" ></span>co</span>nnect(e){<span class="cstat-no" title="statement not covered" >return this.open(e)}<span class="fstat-no" title="function not covered" ></span>on</span>open(){<span class="cstat-no" title="statement not covered" >f("open"),this.cleanup(),this._readyState="open",this.emitReserved("open");c</span>onst e=<span class="cstat-no" title="statement not covered" >this.engine;<span class="cstat-no" title="statement not covered" ></span>this.subs.push(l.on(e,"ping",this.onping.bind(this)),l.on(e,"data",this.ondata.bind(this)),l.on(e,"error",this.onerror.bind(this)),l.on(e,"close",this.onclose.bind(this)),l.on(this.decoder,"decoded",this.ondecoded.bind(this)))}<span class="fstat-no" title="function not covered" ></span>on</span>ping(){<span class="cstat-no" title="statement not covered" >this.emitReserved("ping")}<span class="fstat-no" title="function not covered" ></span>on</span>data(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.decoder.add(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.onclose("parse error",e)}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>decoded(e){<span class="cstat-no" title="statement not covered" >a.nextTick((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.emitReserved("packet",e)}</span>),this.setTimeoutFn)}<span class="fstat-no" title="function not covered" ></span>on</span>error(e){<span class="cstat-no" title="statement not covered" >f("error",e),this.emitReserved("error",e)}<span class="fstat-no" title="function not covered" ></span>so</span>cket(e,t){let n=<span class="cstat-no" title="statement not covered" >this.nsps[e];<span class="cstat-no" title="statement not covered" ></span>return n?this._autoConnect&amp;&amp;!n.active&amp;&amp;n.connect():(n=new c.Socket(this,e,t),this.nsps[e]=n),n}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(e){const t=<span class="cstat-no" title="statement not covered" >Object.keys(this.nsps);<span class="cstat-no" title="statement not covered" ></span>for(const e of t)<span class="cstat-no" title="statement not covered" >if(this.nsps[e].active)<span class="cstat-no" title="statement not covered" >return void f("socket %s is still active, skipping close",e);<span class="cstat-no" title="statement not covered" >t</span></span></span>his._close()}<span class="fstat-no" title="function not covered" ></span>_p</span>acket(e){<span class="cstat-no" title="statement not covered" >f("writing packet %j",e);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.encoder.encode(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >this.engine.write(t[n],e.options)}<span class="fstat-no" title="function not covered" ></span></span>cl</span>eanup(){<span class="cstat-no" title="statement not covered" >f("cleanup"),this.subs.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e())</span>),this.subs.length=0,this.decoder.destroy()}<span class="fstat-no" title="function not covered" ></span>_c</span>lose(){<span class="cstat-no" title="statement not covered" >f("disconnect"),this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&amp;&amp;this.engine.close()}<span class="fstat-no" title="function not covered" ></span>di</span>sconnect(){<span class="cstat-no" title="statement not covered" >return this._close()}<span class="fstat-no" title="function not covered" ></span>on</span>close(e,t){<span class="cstat-no" title="statement not covered" >f("closed due to %s",e),this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",e,t),this._reconnection&amp;&amp;!this.skipReconnect&amp;&amp;this.reconnect()}<span class="fstat-no" title="function not covered" ></span>re</span>connect(){<span class="cstat-no" title="statement not covered" >if(this._reconnecting||this.skipReconnect)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.backoff.attempts&gt;=this._reconnectionAttempts)<span class="cstat-no" title="statement not covered" >f("reconnect failed"),this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >this.backoff.duration();<span class="cstat-no" title="statement not covered" ></span>f("will wait %dms before reconnect attempt",t),this._reconnecting=!0;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.skipReconnect||(f("attempting reconnect"),this.emitReserved("reconnect_attempt",e.backoff.attempts),e.skipReconnect||e.open((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t?(f("reconnect attempt error"),e._reconnecting=!1,e.reconnect(),this.emitReserved("reconnect_error",t)):(f("reconnect success"),e.onreconnect())}</span>)))}</span>),t);<span class="cstat-no" title="statement not covered" ></span>this.opts.autoUnref&amp;&amp;n.unref(),this.subs.push((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.clearTimeoutFn(n)}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>reconnect(){const e=<span class="cstat-no" title="statement not covered" >this.backoff.attempts;<span class="cstat-no" title="statement not covered" ></span>this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",e)}</span>}<span class="cstat-no" title="statement not covered" >t.Manager=p}</span>,7149:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.on=void 0,t.on=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return e.on(t,n),<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.off(t,n)}</span>}</span>}</span>,8312:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.Socket=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(4514),</span>o=<span class="cstat-no" title="statement not covered" >n(7149),</span>i=<span class="cstat-no" title="statement not covered" >n(5260),</span>a=<span class="cstat-no" title="statement not covered" >r(n(1227)).default("socket.io-client:socket"),</span>c=<span class="cstat-no" title="statement not covered" >Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});</span>class u extends i.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=e,this.nsp=t,n&amp;&amp;n.auth&amp;&amp;(this.auth=n.auth),this._opts=Object.assign({},n),this.io._autoConnect&amp;&amp;this.open()}<span class="fstat-no" title="function not covered" ></span>ge</span>t disconnected(){<span class="cstat-no" title="statement not covered" >return!this.connected}<span class="fstat-no" title="function not covered" ></span>su</span>bEvents(){<span class="cstat-no" title="statement not covered" >if(this.subs)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.io;<span class="cstat-no" title="statement not covered" ></span>this.subs=[o.on(e,"open",this.onopen.bind(this)),o.on(e,"packet",this.onpacket.bind(this)),o.on(e,"error",this.onerror.bind(this)),o.on(e,"close",this.onclose.bind(this))]}<span class="fstat-no" title="function not covered" ></span>ge</span>t active(){<span class="cstat-no" title="statement not covered" >return!!this.subs}<span class="fstat-no" title="function not covered" ></span>co</span>nnect(){<span class="cstat-no" title="statement not covered" >return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&amp;&amp;this.onopen()),this}<span class="fstat-no" title="function not covered" ></span>op</span>en(){<span class="cstat-no" title="statement not covered" >return this.connect()}<span class="fstat-no" title="function not covered" ></span>se</span>nd(...e){<span class="cstat-no" title="statement not covered" >return e.unshift("message"),this.emit.apply(this,e),this}<span class="fstat-no" title="function not covered" ></span>em</span>it(e,...t){<span class="cstat-no" title="statement not covered" >if(c.hasOwnProperty(e))<span class="cstat-no" title="statement not covered" >throw new Error('"'+e.toString()+'" is a reserved event name');<span class="cstat-no" title="statement not covered" >i</span></span>f(t.unshift(e),this._opts.retries&amp;&amp;!this.flags.fromQueue&amp;&amp;!this.flags.volatile)<span class="cstat-no" title="statement not covered" >return this._addToQueue(t),this;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >{type:s.PacketType.EVENT,data:t,options:{}};<span class="cstat-no" title="statement not covered" ></span>if(n.options.compress=!1!==this.flags.compress,"function"==typeof t[t.length-1]){const e=<span class="cstat-no" title="statement not covered" >this.ids++;<span class="cstat-no" title="statement not covered" ></span>a("emitting packet with ack id %d",e);c</span>onst r=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" ></span>this._registerAckCallback(e,r),n.id=e}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >this.io.engine&amp;&amp;this.io.engine.transport&amp;&amp;this.io.engine.transport.writable;<span class="cstat-no" title="statement not covered" ></span>return!this.flags.volatile||r&amp;&amp;this.connected?this.connected?(this.notifyOutgoingListeners(n),this.packet(n)):this.sendBuffer.push(n):a("discard packet as the transport is not currently writable"),this.flags={},this}<span class="fstat-no" title="function not covered" ></span>_r</span>egisterAckCallback(e,t){var n;const r=<span class="cstat-no" title="statement not covered" >null!==(n=this.flags.timeout)&amp;&amp;void 0!==n?n:this._opts.ackTimeout;<span class="cstat-no" title="statement not covered" ></span>if(void 0===r)<span class="cstat-no" title="statement not covered" >return void(this.acks[e]=t);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.io.setTimeoutFn((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >delete this.acks[e];<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;this.sendBuffer.length;t++)<span class="cstat-no" title="statement not covered" >this.sendBuffer[t].id===e&amp;&amp;(a("removing packet with ack id %d from the buffer",e),this.sendBuffer.splice(t,1));<span class="cstat-no" title="statement not covered" >a</span></span>("event with ack id %d has timed out after %d ms",e,r),t.call(this,new Error("operation has timed out"))}</span>),r);<span class="cstat-no" title="statement not covered" ></span>this.acks[e]=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{<span class="cstat-no" title="statement not covered" >this.io.clearTimeoutFn(s),t.apply(this,[null,...e])}</span>}<span class="fstat-no" title="function not covered" ></span>em</span>itWithAck(e,...t){const n=<span class="cstat-no" title="statement not covered" >void 0!==this.flags.timeout||void 0!==this._opts.ackTimeout;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >t.push((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >n?e?s(e):r(t):r(e))</span>),this.emit(e,...t)}</span>))}<span class="fstat-no" title="function not covered" ></span>_a</span>ddToQueue(e){let t;<span class="cstat-no" title="statement not covered" >"function"==typeof e[e.length-1]&amp;&amp;(t=e.pop());c</span>onst n=<span class="cstat-no" title="statement not covered" >{id:this._queueSeq++,tryCount:0,pending:!1,args:e,flags:Object.assign({fromQueue:!0},this.flags)};<span class="cstat-no" title="statement not covered" ></span>e.push((<span class="fstat-no" title="function not covered" >(e</span>,...r)=&gt;{<span class="cstat-no" title="statement not covered" >if(n===this._queue[0])<span class="cstat-no" title="statement not covered" >return null!==e?n.tryCount&gt;this._opts.retries&amp;&amp;(a("packet [%d] is discarded after %d tries",n.id,n.tryCount),this._queue.shift(),t&amp;&amp;t(e)):(a("packet [%d] was successfully sent",n.id),this._queue.shift(),t&amp;&amp;t(null,...r)),n.pending=!1,this._drainQueue()}</span></span>)),this._queue.push(n),this._drainQueue()}<span class="fstat-no" title="function not covered" ></span>_d</span>rainQueue(e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(a("draining queue"),!this.connected||0===this._queue.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._queue[0];<span class="cstat-no" title="statement not covered" ></span>!t.pending||e?(t.pending=!0,t.tryCount++,a("sending packet [%d] (try n%d)",t.id,t.tryCount),this.flags=t.flags,this.emit.apply(this,t.args)):a("packet [%d] has already been sent and is waiting for an ack",t.id)}<span class="fstat-no" title="function not covered" ></span>pa</span>cket(e){<span class="cstat-no" title="statement not covered" >e.nsp=this.nsp,this.io._packet(e)}<span class="fstat-no" title="function not covered" ></span>on</span>open(){<span class="cstat-no" title="statement not covered" >a("transport is open - connecting"),"function"==typeof this.auth?this.auth((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._sendConnectPacket(e)}</span>)):this._sendConnectPacket(this.auth)}<span class="fstat-no" title="function not covered" ></span>_s</span>endConnectPacket(e){<span class="cstat-no" title="statement not covered" >this.packet({type:s.PacketType.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},e):e})}<span class="fstat-no" title="function not covered" ></span>on</span>error(e){<span class="cstat-no" title="statement not covered" >this.connected||this.emitReserved("connect_error",e)}<span class="fstat-no" title="function not covered" ></span>on</span>close(e,t){<span class="cstat-no" title="statement not covered" >a("close (%s)",e),this.connected=!1,delete this.id,this.emitReserved("disconnect",e,t)}<span class="fstat-no" title="function not covered" ></span>on</span>packet(e){<span class="cstat-no" title="statement not covered" >if(e.nsp===this.nsp)<span class="cstat-no" title="statement not covered" >switch(e.type){case s.PacketType.CONNECT:<span class="cstat-no" title="statement not covered" >e.data&amp;&amp;e.data.sid?this.onconnect(e.data.sid,e.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.PacketType.EVENT:case s.PacketType.BINARY_EVENT:<span class="cstat-no" title="statement not covered" >this.onevent(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.PacketType.ACK:case s.PacketType.BINARY_ACK:<span class="cstat-no" title="statement not covered" >this.onack(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.PacketType.DISCONNECT:<span class="cstat-no" title="statement not covered" >this.ondisconnect();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.PacketType.CONNECT_ERROR:<span class="cstat-no" title="statement not covered" >this.destroy();c</span>onst t=<span class="cstat-no" title="statement not covered" >new Error(e.data.message);<span class="cstat-no" title="statement not covered" ></span>t.data=e.data.data,this.emitReserved("connect_error",t)}</span>}<span class="fstat-no" title="function not covered" ></span></span>on</span>event(e){const t=<span class="cstat-no" title="statement not covered" >e.data||[];<span class="cstat-no" title="statement not covered" ></span>a("emitting event %j",t),null!=e.id&amp;&amp;(a("attaching ack callback to event"),t.push(this.ack(e.id))),this.connected?this.emitEvent(t):this.receiveBuffer.push(Object.freeze(t))}<span class="fstat-no" title="function not covered" ></span>em</span>itEvent(e){<span class="cstat-no" title="statement not covered" >if(this._anyListeners&amp;&amp;this._anyListeners.length){const t=<span class="cstat-no" title="statement not covered" >this._anyListeners.slice();<span class="cstat-no" title="statement not covered" ></span>for(const n of t)<span class="cstat-no" title="statement not covered" >n.apply(this,e)}<span class="cstat-no" title="statement not covered" ></span></span>s</span>uper.emit.apply(this,e),this._pid&amp;&amp;e.length&amp;&amp;"string"==typeof e[e.length-1]&amp;&amp;(this._lastOffset=e[e.length-1])}<span class="fstat-no" title="function not covered" ></span>ac</span>k(e){const t=<span class="cstat-no" title="statement not covered" >this;</span>let n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...r){<span class="cstat-no" title="statement not covered" >n||(n=!0,a("sending ack %j",r),t.packet({type:s.PacketType.ACK,id:e,data:r}))}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ack(e){const t=<span class="cstat-no" title="statement not covered" >this.acks[e.id];<span class="cstat-no" title="statement not covered" ></span>"function"==typeof t?(a("calling ack %s with %j",e.id,e.data),t.apply(this,e.data),delete this.acks[e.id]):a("bad ack %s",e.id)}<span class="fstat-no" title="function not covered" ></span>on</span>connect(e,t){<span class="cstat-no" title="statement not covered" >a("socket connected with id %s",e),this.id=e,this.recovered=t&amp;&amp;this._pid===t,this._pid=t,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}<span class="fstat-no" title="function not covered" ></span>em</span>itBuffered(){<span class="cstat-no" title="statement not covered" >this.receiveBuffer.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.emitEvent(e))</span>),this.receiveBuffer=[],this.sendBuffer.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.notifyOutgoingListeners(e),this.packet(e)}</span>)),this.sendBuffer=[]}<span class="fstat-no" title="function not covered" ></span>on</span>disconnect(){<span class="cstat-no" title="statement not covered" >a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.subs&amp;&amp;(this.subs.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e())</span>),this.subs=void 0),this.io._destroy(this)}<span class="fstat-no" title="function not covered" ></span>di</span>sconnect(){<span class="cstat-no" title="statement not covered" >return this.connected&amp;&amp;(a("performing disconnect (%s)",this.nsp),this.packet({type:s.PacketType.DISCONNECT})),this.destroy(),this.connected&amp;&amp;this.onclose("io client disconnect"),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ose(){<span class="cstat-no" title="statement not covered" >return this.disconnect()}<span class="fstat-no" title="function not covered" ></span>co</span>mpress(e){<span class="cstat-no" title="statement not covered" >return this.flags.compress=e,this}<span class="fstat-no" title="function not covered" ></span>ge</span>t volatile(){<span class="cstat-no" title="statement not covered" >return this.flags.volatile=!0,this}<span class="fstat-no" title="function not covered" ></span>ti</span>meout(e){<span class="cstat-no" title="statement not covered" >return this.flags.timeout=e,this}<span class="fstat-no" title="function not covered" ></span>on</span>Any(e){<span class="cstat-no" title="statement not covered" >return this._anyListeners=this._anyListeners||[],this._anyListeners.push(e),this}<span class="fstat-no" title="function not covered" ></span>pr</span>ependAny(e){<span class="cstat-no" title="statement not covered" >return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(e),this}<span class="fstat-no" title="function not covered" ></span>of</span>fAny(e){<span class="cstat-no" title="statement not covered" >if(!this._anyListeners)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(e){const t=<span class="cstat-no" title="statement not covered" >this._anyListeners;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(e===t[n])<span class="cstat-no" title="statement not covered" >return t.splice(n,1),this}</span></span></span>else <span class="cstat-no" title="statement not covered" >this._anyListeners=[];<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>li</span>stenersAny(){<span class="cstat-no" title="statement not covered" >return this._anyListeners||[]}<span class="fstat-no" title="function not covered" ></span>on</span>AnyOutgoing(e){<span class="cstat-no" title="statement not covered" >return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(e),this}<span class="fstat-no" title="function not covered" ></span>pr</span>ependAnyOutgoing(e){<span class="cstat-no" title="statement not covered" >return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(e),this}<span class="fstat-no" title="function not covered" ></span>of</span>fAnyOutgoing(e){<span class="cstat-no" title="statement not covered" >if(!this._anyOutgoingListeners)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(e){const t=<span class="cstat-no" title="statement not covered" >this._anyOutgoingListeners;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(e===t[n])<span class="cstat-no" title="statement not covered" >return t.splice(n,1),this}</span></span></span>else <span class="cstat-no" title="statement not covered" >this._anyOutgoingListeners=[];<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>li</span>stenersAnyOutgoing(){<span class="cstat-no" title="statement not covered" >return this._anyOutgoingListeners||[]}<span class="fstat-no" title="function not covered" ></span>no</span>tifyOutgoingListeners(e){<span class="cstat-no" title="statement not covered" >if(this._anyOutgoingListeners&amp;&amp;this._anyOutgoingListeners.length){const t=<span class="cstat-no" title="statement not covered" >this._anyOutgoingListeners.slice();<span class="cstat-no" title="statement not covered" ></span>for(const n of t)<span class="cstat-no" title="statement not covered" >n.apply(this,e.data)}</span></span>}</span>}<span class="cstat-no" title="statement not covered" >t.Socket=u}</span>,3084:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__importDefault||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.__esModule?e:{default:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0}),t.url=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(4679),</span>o=<span class="cstat-no" title="statement not covered" >r(n(1227)).default("socket.io-client:url");<span class="cstat-no" title="statement not covered" ></span>t.url=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n){let r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>n=n||"undefined"!=typeof location&amp;&amp;location,null==e&amp;&amp;(e=n.protocol+"//"+n.host),"string"==typeof e&amp;&amp;("/"===e.charAt(0)&amp;&amp;(e="/"===e.charAt(1)?n.protocol+e:n.host+e),/^(https?|wss?):\/\//.test(e)||(o("protocol-less url %s",e),e=void 0!==n?n.protocol+"//"+e:"https://"+e),o("parse %s",e),r=s.parse(e)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&amp;&amp;(r.port="443")),r.path=r.path||"/";c</span>onst i=<span class="cstat-no" title="statement not covered" >-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;<span class="cstat-no" title="statement not covered" ></span>return r.id=r.protocol+"://"+i+":"+r.port+t,r.href=r.protocol+"://"+i+(n&amp;&amp;n.port===r.port?"":":"+r.port),r}</span>}</span>,4880:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.reconstructPacket=t.deconstructPacket=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(665);</span>function <span class="fstat-no" title="function not covered" >s(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f((0,r.isBinary)(e)){const n=<span class="cstat-no" title="statement not covered" >{_placeholder:!0,num:t.length};<span class="cstat-no" title="statement not covered" ></span>return t.push(e),n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Array.isArray(e)){const n=<span class="cstat-no" title="statement not covered" >new Array(e.length);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++)<span class="cstat-no" title="statement not covered" >n[r]=s(e[r],t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f("object"==typeof e&amp;&amp;!(e instanceof Date)){const n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(n[r]=s(e[r],t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >o(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(e&amp;&amp;!0===e._placeholder){<span class="cstat-no" title="statement not covered" >if("number"==typeof e.num&amp;&amp;e.num&gt;=0&amp;&amp;e.num&lt;t.length)<span class="cstat-no" title="statement not covered" >return t[e.num];<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("illegal attachments")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >e[n]=o(e[n],t);e</span></span>lse <span class="cstat-no" title="statement not covered" >if("object"==typeof e)<span class="cstat-no" title="statement not covered" >for(const n in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,n)&amp;&amp;(e[n]=o(e[n],t));<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>t.deconstructPacket=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >e.data,</span>r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.data=s(n,t),r.attachments=t.length,{packet:r,buffers:t}}</span>,t.reconstructPacket=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.data=o(e.data,t),delete e.attachments,e}</span>}</span>,4514:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.Decoder=t.Encoder=t.PacketType=t.protocol=void 0;c</span>onst r=<span class="cstat-no" title="statement not covered" >n(5260),</span>s=<span class="cstat-no" title="statement not covered" >n(4880),</span>o=<span class="cstat-no" title="statement not covered" >n(665),</span>i=<span class="cstat-no" title="statement not covered" >(0,n(1227).default)("socket.io-parser"),</span>a=<span class="cstat-no" title="statement not covered" >["connect","connect_error","disconnect","disconnecting","newListener","removeListener"];</span>var c;function <span class="fstat-no" title="function not covered" >u(</span>e){<span class="cstat-no" title="statement not covered" >return"[object Object]"===Object.prototype.toString.call(e)}<span class="cstat-no" title="statement not covered" ></span>t.protocol=5,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[e.CONNECT=0]="CONNECT",e[e.DISCONNECT=1]="DISCONNECT",e[e.EVENT=2]="EVENT",e[e.ACK=3]="ACK",e[e.CONNECT_ERROR=4]="CONNECT_ERROR",e[e.BINARY_EVENT=5]="BINARY_EVENT",e[e.BINARY_ACK=6]="BINARY_ACK"}</span>(c=t.PacketType||(t.PacketType={})),t.Encoder=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this.replacer=e}<span class="fstat-no" title="function not covered" ></span>en</span>code(e){<span class="cstat-no" title="statement not covered" >return i("encoding packet %j",e),e.type!==c.EVENT&amp;&amp;e.type!==c.ACK||!(0,o.hasBinary)(e)?[this.encodeAsString(e)]:this.encodeAsBinary({type:e.type===c.EVENT?c.BINARY_EVENT:c.BINARY_ACK,nsp:e.nsp,data:e.data,id:e.id})}<span class="fstat-no" title="function not covered" ></span>en</span>codeAsString(e){let t=<span class="cstat-no" title="statement not covered" >""+e.type;<span class="cstat-no" title="statement not covered" ></span>return e.type!==c.BINARY_EVENT&amp;&amp;e.type!==c.BINARY_ACK||(t+=e.attachments+"-"),e.nsp&amp;&amp;"/"!==e.nsp&amp;&amp;(t+=e.nsp+","),null!=e.id&amp;&amp;(t+=e.id),null!=e.data&amp;&amp;(t+=JSON.stringify(e.data,this.replacer)),i("encoded %j as %s",e,t),t}<span class="fstat-no" title="function not covered" ></span>en</span>codeAsBinary(e){const t=<span class="cstat-no" title="statement not covered" >(0,s.deconstructPacket)(e),</span>n=<span class="cstat-no" title="statement not covered" >this.encodeAsString(t.packet),</span>r=<span class="cstat-no" title="statement not covered" >t.buffers;<span class="cstat-no" title="statement not covered" ></span>return r.unshift(n),r}</span>};c</span>lass l extends r.Emitter{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(),this.reviver=e}<span class="fstat-no" title="function not covered" ></span>ad</span>d(e){let t;<span class="cstat-no" title="statement not covered" >if("string"==typeof e){<span class="cstat-no" title="statement not covered" >if(this.reconstructor)<span class="cstat-no" title="statement not covered" >throw new Error("got plaintext data when reconstructing a packet");<span class="cstat-no" title="statement not covered" >t</span></span>=this.decodeString(e);c</span>onst n=<span class="cstat-no" title="statement not covered" >t.type===c.BINARY_EVENT;<span class="cstat-no" title="statement not covered" ></span>n||t.type===c.BINARY_ACK?(t.type=n?c.EVENT:c.ACK,this.reconstructor=new h(t),0===t.attachments&amp;&amp;super.emitReserved("decoded",t)):super.emitReserved("decoded",t)}</span>else{<span class="cstat-no" title="statement not covered" >if(!(0,o.isBinary)(e)&amp;&amp;!e.base64)<span class="cstat-no" title="statement not covered" >throw new Error("Unknown type: "+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.reconstructor)<span class="cstat-no" title="statement not covered" >throw new Error("got binary data when not reconstructing a packet");<span class="cstat-no" title="statement not covered" >t</span></span>=this.reconstructor.takeBinaryData(e),t&amp;&amp;(this.reconstructor=null,super.emitReserved("decoded",t))}</span>}<span class="fstat-no" title="function not covered" ></span>de</span>codeString(e){let t=<span class="cstat-no" title="statement not covered" >0;</span>const n=<span class="cstat-no" title="statement not covered" >{type:Number(e.charAt(0))};<span class="cstat-no" title="statement not covered" ></span>if(void 0===c[n.type])<span class="cstat-no" title="statement not covered" >throw new Error("unknown packet type "+n.type);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type===c.BINARY_EVENT||n.type===c.BINARY_ACK){const r=<span class="cstat-no" title="statement not covered" >t+1;<span class="cstat-no" title="statement not covered" ></span>for(;"-"!==e.charAt(++t)&amp;&amp;t!=e.length;);c</span>onst s=<span class="cstat-no" title="statement not covered" >e.substring(r,t);<span class="cstat-no" title="statement not covered" ></span>if(s!=Number(s)||"-"!==e.charAt(t))<span class="cstat-no" title="statement not covered" >throw new Error("Illegal attachments");<span class="cstat-no" title="statement not covered" >n</span></span>.attachments=Number(s)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("/"===e.charAt(t+1)){const r=<span class="cstat-no" title="statement not covered" >t+1;<span class="cstat-no" title="statement not covered" ></span>for(;++t&amp;&amp;","!==e.charAt(t)&amp;&amp;t!==e.length;);<span class="cstat-no" title="statement not covered" >n</span>.nsp=e.substring(r,t)}</span>else <span class="cstat-no" title="statement not covered" >n.nsp="/";c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.charAt(t+1);<span class="cstat-no" title="statement not covered" ></span>if(""!==r&amp;&amp;Number(r)==r){const r=<span class="cstat-no" title="statement not covered" >t+1;<span class="cstat-no" title="statement not covered" ></span>for(;++t;){const n=<span class="cstat-no" title="statement not covered" >e.charAt(t);<span class="cstat-no" title="statement not covered" ></span>if(null==n||Number(n)!=n){<span class="cstat-no" title="statement not covered" >--t;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t===e.length)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>n</span>.id=Number(e.substring(r,t+1))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.charAt(++t)){const r=<span class="cstat-no" title="statement not covered" >this.tryParse(e.substr(t));<span class="cstat-no" title="statement not covered" ></span>if(!l.isPayloadValid(n.type,r))<span class="cstat-no" title="statement not covered" >throw new Error("invalid payload");<span class="cstat-no" title="statement not covered" >n</span></span>.data=r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i("decoded %s as %j",e,n),n}<span class="fstat-no" title="function not covered" ></span>tr</span>yParse(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(e,this.reviver)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return!1}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic isPayloadValid(e,t){<span class="cstat-no" title="statement not covered" >switch(e){case c.CONNECT:<span class="cstat-no" title="statement not covered" >return u(t);c</span>ase c.DISCONNECT:<span class="cstat-no" title="statement not covered" >return void 0===t;c</span>ase c.CONNECT_ERROR:<span class="cstat-no" title="statement not covered" >return"string"==typeof t||u(t);c</span>ase c.EVENT:case c.BINARY_EVENT:<span class="cstat-no" title="statement not covered" >return Array.isArray(t)&amp;&amp;("number"==typeof t[0]||"string"==typeof t[0]&amp;&amp;-1===a.indexOf(t[0]));c</span>ase c.ACK:case c.BINARY_ACK:<span class="cstat-no" title="statement not covered" >return Array.isArray(t)}</span>}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.reconstructor&amp;&amp;(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}</span>}<span class="cstat-no" title="statement not covered" >t.Decoder=l;c</span>lass h{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this.packet=e,this.buffers=[],this.reconPack=e}<span class="fstat-no" title="function not covered" ></span>ta</span>keBinaryData(e){<span class="cstat-no" title="statement not covered" >if(this.buffers.push(e),this.buffers.length===this.reconPack.attachments){const e=<span class="cstat-no" title="statement not covered" >(0,s.reconstructPacket)(this.reconPack,this.buffers);<span class="cstat-no" title="statement not covered" ></span>return this.finishedReconstruction(),e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}<span class="fstat-no" title="function not covered" ></span>fi</span>nishedReconstruction(){<span class="cstat-no" title="statement not covered" >this.reconPack=null,this.buffers=[]}</span>}},665:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"__esModule",{value:!0}),t.hasBinary=t.isBinary=void 0;c</span>onst n=<span class="cstat-no" title="statement not covered" >"function"==typeof ArrayBuffer,</span>r=<span class="cstat-no" title="statement not covered" >Object.prototype.toString,</span>s=<span class="cstat-no" title="statement not covered" >"function"==typeof Blob||"undefined"!=typeof Blob&amp;&amp;"[object BlobConstructor]"===r.call(Blob),</span>o=<span class="cstat-no" title="statement not covered" >"function"==typeof File||"undefined"!=typeof File&amp;&amp;"[object FileConstructor]"===r.call(File);</span>function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >return n&amp;&amp;(e instanceof ArrayBuffer||(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):e.buffer instanceof ArrayBuffer)</span>(e))||s&amp;&amp;e instanceof Blob||o&amp;&amp;e instanceof File}<span class="cstat-no" title="statement not covered" ></span>t.isBinary=i,t.hasBinary=function <span class="fstat-no" title="function not covered" >e(</span>t,n){<span class="cstat-no" title="statement not covered" >if(!t||"object"!=typeof t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >t.length;</span>n&lt;r;n++)<span class="cstat-no" title="statement not covered" >if(e(t[n]))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i(t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.toJSON&amp;&amp;"function"==typeof t.toJSON&amp;&amp;1===arguments.length)<span class="cstat-no" title="statement not covered" >return e(t.toJSON(),!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const n in t)<span class="cstat-no" title="statement not covered" >if(Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;e(t[n]))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>}</span>,5260:<span class="fstat-no" title="function not covered" >(e</span>,t,n)=&gt;{"use strict";function <span class="fstat-no" title="function not covered" >r(</span>e){<span class="cstat-no" title="statement not covered" >if(e)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t in r.prototype)<span class="cstat-no" title="statement not covered" >e[t]=r.prototype[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e)}<span class="cstat-no" title="statement not covered" ></span></span>n.r(t),n.d(t,{Emitter:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r}</span>),r.prototype.on=r.prototype.addEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this}</span>,r.prototype.once=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){function <span class="fstat-no" title="function not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >this.off(e,n),t.apply(this,arguments)}<span class="cstat-no" title="statement not covered" ></span>return n.fn=t,this.on(e,n),this}</span>,r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(this._callbacks=this._callbacks||{},0==arguments.length)<span class="cstat-no" title="statement not covered" >return this._callbacks={},this;v</span></span>ar n,r=<span class="cstat-no" title="statement not covered" >this._callbacks["$"+e];<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(1==arguments.length)<span class="cstat-no" title="statement not covered" >return delete this._callbacks["$"+e],this;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >if((n=r[s])===t||n.fn===t){<span class="cstat-no" title="statement not covered" >r.splice(s,1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn 0===r.length&amp;&amp;delete this._callbacks["$"+e],this}</span>,r.prototype.emit=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._callbacks=this._callbacks||{};<span class="cstat-no" title="statement not covered" >f</span>or(var t=<span class="cstat-no" title="statement not covered" >new Array(arguments.length-1),</span>n=<span class="cstat-no" title="statement not covered" >this._callbacks["$"+e],</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;arguments.length;r++)<span class="cstat-no" title="statement not covered" >t[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >i</span></span>f(n){<span class="cstat-no" title="statement not covered" >r=0;<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >(n=n.slice(0)).length;</span>r&lt;s;++r)<span class="cstat-no" title="statement not covered" >n[r].apply(this,t)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this}</span>,r.prototype.emitReserved=r.prototype.emit,r.prototype.listeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]}</span>,r.prototype.hasListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!!this.listeners(e).length}</span>}</span>},</span>t=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >n(</span>r){var s=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==s)<span class="cstat-no" title="statement not covered" >return s.exports;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t[r]={exports:{}};<span class="cstat-no" title="statement not covered" ></span>return e[r].call(o.exports,o,o.exports,n),o.exports}<span class="cstat-no" title="statement not covered" ></span>n.d=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >n.o(t,r)&amp;&amp;!n.o(e,r)&amp;&amp;Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}</span></span>,n.g=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if("object"==typeof globalThis)<span class="cstat-no" title="statement not covered" >return globalThis;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return this||new Function("return this")()}</span>catch(e){<span class="cstat-no" title="statement not covered" >if("object"==typeof window)<span class="cstat-no" title="statement not covered" >return window}</span></span>}</span>(),n.o=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,t),</span>n.r=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >"undefined"!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}</span>;v</span>ar r=<span class="cstat-no" title="statement not covered" >n(9623);<span class="cstat-no" title="statement not covered" ></span>CctLce=r}</span>)();</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-03-17T10:38:32.575Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    